<!DOCTYPE html><html lang="en" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="A Survey of Windows RPC Discovery Tools" /><meta name="author" content="clearbluejar" /><meta property="og:locale" content="en" /><meta name="description" content="A survey of Windows Remote Procedure Call discovery tools and an attempt to understand how open source tools discover RPC servers, interfaces, and procedures." /><meta property="og:description" content="A survey of Windows Remote Procedure Call discovery tools and an attempt to understand how open source tools discover RPC servers, interfaces, and procedures." /><link rel="canonical" href="https://clearbluejar.github.io/posts/surveying-windows-rpc-discovery-tools/" /><meta property="og:url" content="https://clearbluejar.github.io/posts/surveying-windows-rpc-discovery-tools/" /><meta property="og:site_name" content="clearbluejar" /><meta property="og:image" content="https://clearbluejar.github.io/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/todd-quackenbush-IClZBVw5W5A-unsplash.jpg" /><meta property="og:image:alt" content="A Survey of RPC Discovery Tools" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-02T05:11:00+00:00" /><meta name="twitter:card" content="summary_large_image" /><meta property="twitter:image" content="https://clearbluejar.github.io/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/todd-quackenbush-IClZBVw5W5A-unsplash.jpg" /><meta name="twitter:image:alt" content="A Survey of RPC Discovery Tools" /><meta property="twitter:title" content="A Survey of Windows RPC Discovery Tools" /><meta name="twitter:site" content="@clearbluejar" /><meta name="twitter:creator" content="@clearbluejar" /><meta name="google-site-verification" content="yeZcjox5p1UhtqcHFYkiXFGf013zyULTn74IVNLoVbE" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"clearbluejar"},"dateModified":"2022-06-24T12:24:21+00:00","datePublished":"2022-06-02T05:11:00+00:00","description":"A survey of Windows Remote Procedure Call discovery tools and an attempt to understand how open source tools discover RPC servers, interfaces, and procedures.","headline":"A Survey of Windows RPC Discovery Tools","image":{"src":"/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/todd-quackenbush-IClZBVw5W5A-unsplash.jpg","alt":"A Survey of RPC Discovery Tools","url":"https://clearbluejar.github.io/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/todd-quackenbush-IClZBVw5W5A-unsplash.jpg","@type":"imageObject"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://clearbluejar.github.io/posts/surveying-windows-rpc-discovery-tools/"},"url":"https://clearbluejar.github.io/posts/surveying-windows-rpc-discovery-tools/"}</script><title>A Survey of Windows RPC Discovery Tools | clearbluejar</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="clearbluejar"><meta name="application-name" content="clearbluejar"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" class="mx-auto"> <img src="https://github.com/clearbluejar.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">clearbluejar</a></div><div class="site-subtitle font-italic">blog, code, and research</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/clearbluejar" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/clearbluejar" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper"><div id="topbar" class="container d-flex align-items-center justify-content-between h-100 pl-3 pr-3 pl-md-4 pr-md-4"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>A Survey of Windows RPC Discovery Tools</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper" class="d-flex justify-content-center"><div id="main" class="container pl-xl-4 pr-xl-4"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-9 pr-xl-4"><div class="post pl-1 pr-1 pl-md-2 pr-md-2"><h1 data-toc-skip>A Survey of Windows RPC Discovery Tools</h1><div class="post-meta text-muted"> <span> Posted <em class="" data-ts="1654146660" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jun 2, 2022 </em> </span> <span> Updated <em class="" data-ts="1656073461" data-df="ll" data-toggle="tooltip" data-placement="bottom"> Jun 24, 2022 </em> </span><div class="mt-3 mb-3"> <img data-src="/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/todd-quackenbush-IClZBVw5W5A-unsplash.jpg" class="preview-img bg" alt="A Survey of RPC Discovery Tools" data-proofer-ignore><figcaption class="pt-2 pb-2">A Survey of RPC Discovery Tools</figcaption></div><div class="d-flex justify-content-between"> <span> By <em> clearbluejar </em> </span><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3444 words"> <em>19 min</em> read</span></div></div></div><div class="post-content"><p><strong>TL;DR A survey of Windows Remote Procedure Call discovery tools and an attempt to understand how open source tools discover RPC servers, interfaces, and procedures.</strong></p><p>Windows RPC has been a black box for me for some time. This post is an attempt to leverage analysis of open source RPC tools to pry open that box. I started by reading MSDN, getting bored and then bouncing between several <a href="https://csandker.io/2021/02/21/Offensive-Windows-IPC-2-RPC.html">detailed</a> security and <a href="https://www.fortinet.com/blog/threat-research/rpc-bug-hunting-case-studies---part-2">research</a> blog <a href="https://itm4n.github.io/fuzzing-windows-rpc-rpcview/">posts</a>. Reading was my first step down the road of Windows RPC comprehension, and it helped me understand RPC at a high level.</p><blockquote><p>Microsoft Remote Procedure Call (RPC) defines a powerful technology for creating distributed client/server programs. The RPC run-time stubs and libraries manage most of the processes relating to network protocols and communication. This enables you to focus on the details of the application rather than the details of the network. -<a href="https://docs.microsoft.com/en-us/windows/win32/rpc/rpc-start-page">MSDN</a></p></blockquote><p>RPC is a way to standardize security and communication across either local or distributed clients and servers. Used in services to provide a separation of privileges (as it supports <a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcimpersonateclient">impersonation</a>) or as means to provide secure communication across a network through available <a href="https://docs.microsoft.com/en-us/windows/win32/rpc/protocol-sequence-constants">transports</a>. It is <a href="https://www.windows-security.org/windows-service/rpc-endpoint-mapper#:~:text=The%20following%20system%20components%20are%20dependent%20on%20the%20RPC%20Endpoint%20Mapper%20service">prolific</a> in Windows and therefore useful to understand for auditing or researching Windows.</p><p>When I’m trying to understand something, reading is hardly ever enough. I often use writing as a tool for understanding (hence this blog). I find I can’t feign understanding in writing. This post will examine existing RPC discovery and enumeration tools hoping to understand each of the tools’ means for RPC discovery.</p><p>Questions to consider:</p><ul><li>Which tools enumerate RPC?<li>By what means can RPC servers (and clients) be found?<li>What are the advantages and disadvantages of dynamic vs static tools?<li>What approaches are used by the various RPC tooling?</ul><h3 id="evidence-of-rpc"><span class="mr-2">Evidence of RPC</span><a href="#evidence-of-rpc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>Here are some well-known ways to identify RPC within a binary.</p><ul><li><strong>Look for the import of rpcrt4.dll</strong><ul><li>Each binary that supports RPC will need to <a href="https://en.wikipedia.org/wiki/Linker_(computing)">link</a> against the RPC runtime (<code class="language-plaintext highlighter-rouge">rpcrt4.dll</code>) to support common RPC actions.<li>The import of rpcrt4.dll may not be found in the binary of the server or application running RPC, it could be in a dependency DLL loaded at runtime with a RPC runtime dependency. This needs to be considered for the tooling looking for RPC, whether you attempt to discover RPC statically (by examining the binary) or dynamically (looking at a process at runtime).</ul><li><strong>Query the RPC endpoint mapper</strong> - Windows runs a service known as the RPC Endpoint Mapper. If (and only if) a RPC server registers with the endpoint mapper via an Win32 API such as <a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcepregister"><code class="language-plaintext highlighter-rouge">RpcEpRegister</code></a> will the server be known to the RPC Endpoint Mapper.</ul><p>These common ways, mentioned in <a href="https://twitter.com/0xcsandker">0xcarsten</a>’s RPC post <a href="https://csandker.io/2021/02/21/Offensive-Windows-IPC-2-RPC.html">here</a>, are also alluded to in MSDN under <a href="https://docs.microsoft.com/en-us/windows/win32/rpc/compiling-and-linking">linking</a> and <a href="https://docs.microsoft.com/en-us/windows/win32/rpc/registering-endpoints">registering endpoints</a>.</p><p>Some of the less known ways include the <strong>walking of RPC data structures</strong> available both in the compiled RPC binary and in a RPC process memory at runtime. These methods, detailed below by tools like <em>RpcView</em> and <em>NtObjectManager</em>, provide the means to not only find RPC servers and clients but also derive the <a href="https://docs.microsoft.com/en-us/windows/win32/rpc/developing-the-interface">interfaces</a> and procedures within the binary.</p><h2 id="rpc-tools---discovering-rpc-servers-interfaces-and-procedures"><span class="mr-2">RPC Tools - Discovering RPC Servers, Interfaces and Procedures</span><a href="#rpc-tools---discovering-rpc-servers-interfaces-and-procedures" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2><p>To begin, we survey the landscape a bit to understand each tool’s heuristic for RPC discovery.</p><h3 id="rpcview"><span class="mr-2">RPCView</span><a href="#rpcview" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/rpcview-github.png" alt="rpcview-github" class="shadow" data-proofer-ignore><em>RpcView</em></p><p>RpcView discovers RPC servers already running on your host. It takes a dynamic (runtime) approach to discovery. RpcView starts by enumerating every running process and discovers the RPC <a href="https://docs.microsoft.com/en-us/windows/win32/rpc/developing-the-interface">interface</a>, <a href="https://docs.microsoft.com/en-us/windows/win32/rpc/finding-endpoints">endpoint</a>, and <a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingsetauthinfo">AuthInfo</a> for each of the running RPC servers it detects. Finally, it displays the results in a nice GUI.</p><p><img data-src="/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/rpcview-gui.png" alt="rpcview-gui" class="shadow" data-proofer-ignore><em>RpcView GUI</em></p><h4 id="code"><span class="mr-2">Code</span><a href="#code" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote><p>Source: https://github.com/silverf0x/RpcView</p></blockquote><p>As far as I can tell by exploring the code related to enumerating interfaces is:</p><ol><li><a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCommon/Misc.c#L86">EnumProcess</a> - The <code class="language-plaintext highlighter-rouge">EnumProcess</code> function enumerates all the processes by iterating through all the PIDs within a current process snapshot (see <a href="https://docs.microsoft.com/en-us/windows/win32/api/tlhelp32/nf-tlhelp32-createtoolhelp32snapshot">CreateToolhelp32Snapshot</a>). It is called when RpcView is <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcView/InitViewsVisitor.cpp#L42">initialized</a> and again as the <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcView/RefreshVisitor.cpp#L45">user clicks</a> on the various widgets (interfaces, endpoints, processes) within the GUI to ensure that a fresh process listing is used.<li><a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L210">GetRpcServerAddressInProcess</a> - For RpcView’s ability to enumerate RPC interfaces, endpoints, and all other RPC information, it first attempts to discover the global symbol <code class="language-plaintext highlighter-rouge">GlobalRpcServer</code> from the <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L235"><em>rpcrt4.dll</em></a> (RPC runtime dll) loaded in the running processes address space. The <code class="language-plaintext highlighter-rouge">GlobalRpcServer</code> variable is a pointer to a root <a href="https://github.com/silverf0x/RpcView/blob/67696389dec705a58704647e590fe4f74fab0d6c/RpcCore/RpcCore4_64bits/RpcInternals.h#L88"><code class="language-plaintext highlighter-rouge">_RPC_SERVER_T</code></a> data structure needed to unravel all related RPC information with a process. The <code class="language-plaintext highlighter-rouge">GlobalRpcServer</code> is found in the the <code class="language-plaintext highlighter-rouge">.data</code> section of the <em>rpcrt4.dll</em>, so for each running process, <code class="language-plaintext highlighter-rouge">GetRpcServerAddressInProcess</code> function searches through the entire <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L237">.data</a> section (brute force style) dereferencing <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L246">one sizeof(void *) pointer at a time</a>) until it finds the <code class="language-plaintext highlighter-rouge">GlobalRpcServer</code> data structure. It identifies the GlobalRpcServer symbol by leveraging RpcView’s <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L198">heuristic</a> to identify the symbol. Essentially, they are searching for a unique RPC <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L180">GUID</a> <em>8a885d04-1ceb-11c9-9fe8-08002b104860</em> known as the <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/b6090c2b-f44a-47a1-a13b-b82ade0137b2">NDR Transfer Syntax Identifier</a>. More details of this heuristic and RPC data structures are better explained by <a href="https://twitter.com/_xpn_"><em>@_xpn_</em></a> in his <a href="https://blog.xpnsec.com/analysing-rpc-with-ghidra-neo4j/">analysis of RPCView</a>. Once found, <code class="language-plaintext highlighter-rouge">GlobalRpcServer</code> is <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L253">assigned</a> and subsequently used as the starting point for the all functionality we care about (<code class="language-plaintext highlighter-rouge">RpcCoreEnumProcessInterfaces</code>, <code class="language-plaintext highlighter-rouge">RpcCoreEnumProcessEndpoints</code>, and <code class="language-plaintext highlighter-rouge">RpcCoreEnumProcessAuthInfo</code>). Each of these functions has a similar start. Open process for reading memory, populate the <code class="language-plaintext highlighter-rouge">_RPC_SERVER_T</code> data structure with the memory pointed to by <code class="language-plaintext highlighter-rouge">GlobalRpcServer</code>.<div file="RpcCore/RpcCore.c" class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="RpcCore/RpcCore.c"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre> <span class="n">BOOL</span> <span class="kr">__fastcall</span> <span class="nf">RpcCoreEnumProcessInterfaces</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">pRpcCoreCtxt</span><span class="p">,</span><span class="n">DWORD</span> <span class="n">Pid</span><span class="p">,</span><span class="n">RpcCoreEnumProcessInterfacesCallbackFn_T</span> <span class="n">RpcCoreEnumProcessInterfacesCallbackFn</span><span class="p">,</span><span class="kt">void</span><span class="o">*</span> <span class="n">pCallbackCtxt</span><span class="p">,</span><span class="n">ULONG</span> <span class="n">InterfaceInfoMask</span><span class="p">)</span>
 <span class="p">{</span>
     <span class="n">HANDLE</span>					<span class="n">hProcess</span><span class="p">;</span>
     <span class="n">BOOL</span>					<span class="n">bResult</span><span class="o">=</span><span class="n">FALSE</span><span class="p">;</span>
     <span class="n">RPC_SERVER_T</span>			<span class="n">RpcServer</span><span class="p">;</span>
     <span class="n">UINT</span>					<span class="n">i</span><span class="p">;</span>
     <span class="n">UINT</span>					<span class="n">Size</span><span class="p">;</span>
     <span class="n">VOID</span> <span class="n">PTR_T</span> <span class="o">*</span>			<span class="n">pTable</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
     <span class="n">VOID</span> <span class="n">PTR_T</span>				<span class="n">pRpcServer</span><span class="p">;</span>
     <span class="n">BOOL</span>					<span class="n">bContinue</span><span class="o">=</span><span class="n">TRUE</span><span class="p">;</span>
     <span class="n">RpcInterfaceInfo_T</span><span class="o">*</span>		<span class="n">pRpcInterfaceInfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
     <span class="n">RpcCoreInternalCtxt_T</span><span class="o">*</span>	<span class="n">pRpcCoreInternalCtxt</span><span class="o">=</span><span class="p">(</span><span class="n">RpcCoreInternalCtxt_T</span><span class="o">*</span><span class="p">)</span><span class="n">pRpcCoreCtxt</span><span class="p">;</span>

     <span class="n">hProcess</span><span class="o">=</span><span class="n">ProcexpOpenProcess</span><span class="p">(</span><span class="n">PROCESS_VM_READ</span><span class="o">|</span><span class="n">PROCESS_QUERY_INFORMATION</span><span class="p">,</span><span class="n">FALSE</span><span class="p">,</span><span class="n">Pid</span><span class="p">);</span>
     <span class="k">if</span> <span class="p">(</span><span class="n">hProcess</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span> <span class="k">goto</span> <span class="n">End</span><span class="p">;</span>

     <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">hProcess</span><span class="p">,</span><span class="n">pRpcCoreInternalCtxt</span><span class="o">-&gt;</span><span class="n">pGlobalRpcServer</span><span class="p">,</span><span class="o">&amp;</span><span class="n">pRpcServer</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">VOID</span> <span class="n">PTR_T</span><span class="p">),</span><span class="nb">NULL</span><span class="p">))</span> <span class="k">goto</span> <span class="n">End</span><span class="p">;</span>
</pre></table></code></div></div><p><sub> <code class="language-plaintext highlighter-rouge">GlobalRpcServer</code> starting point within <code class="language-plaintext highlighter-rouge">RpcCoreEnumProcessInterfaces</code> assigned to RPC_SERVER_T data structure </sub></p><li><a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L854">RpcCoreEnumProcessInterfaces</a> - Enumerating RPC interfaces and procedures in a process. Starting with the <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L870"><code class="language-plaintext highlighter-rouge">GlobalRPCServer</code></a> the basic objective is to dig into its <a href="https://github.com/silverf0x/RpcView/blob/67696389dec705a58704647e590fe4f74fab0d6c/RpcCore/RpcCore4_64bits/RpcInternals.h#L88"><code class="language-plaintext highlighter-rouge">_RPC_SERVER_T</code></a> data structure to identify the RPC interface <a href="https://github.com/silverf0x/RpcView/blob/67696389dec705a58704647e590fe4f74fab0d6c/RpcCore/RpcCore4_64bits/RpcInternals.h#L124"><code class="language-plaintext highlighter-rouge">_RPC_INTERFACE_T</code></a> data structures. <code class="language-plaintext highlighter-rouge">RpcCoreEnumProcessInterfaces</code> <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L883">iterates</a> through all the interfaces and pulls out detailed information via <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L584">InternalGetInterfaceInfo</a>. The <code class="language-plaintext highlighter-rouge">InternalGetInterfaceInfo</code> function copies data from process memory to populate a detailed <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.h#L95"><code class="language-plaintext highlighter-rouge">RpcInterfaceInfo_T</code></a> data structure used by RpcView to <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L888">update</a> the GUI. The RPC interface <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L627">IDs</a> and <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L773">procedure address table</a> are populated within this function. The procedure names for the interface are not available from process memory, but are later <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcView/InterfaceSelectedVisitor.cpp#L154">enriched</a> by referencing the <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcView/Pdb.c#L170">PDB symbols for the corresponding binary</a> and the procedure address table to produce the procedure names (assuming symbols are configured).<li><a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L903">RpcCoreEnumProcessEndpoints</a> - Enumerating RPC endpoints in a process. This function again relies on the base <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L923"><code class="language-plaintext highlighter-rouge">GlobalRPCServer</code></a> data structure and <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L935">iterates</a> a simple array that holds the RPC endpoint information (specifically the <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L939">name</a> and <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L938">protocol</a>) for the endpoint. There can be more than one endpoint within a process.<li><a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L995">RpcCoreEnumProcessAuthInfo</a> - Enumerate the AuthInfo in a RPC process. Just like the previous two, starting with <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L1022"><code class="language-plaintext highlighter-rouge">GlobalRPCServer</code></a>, <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L1031">iterating</a> over the AuthInfo, and populating RpcView’s <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.h#L166">RpcAuthInfo_T</a> data structure.</ol><h4 id="thoughts"><span class="mr-2">Thoughts</span><a href="#thoughts" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>RpcView’s runtime approach to RPC discovery has both advantages and disadvantages. An immediate disadvantage that comes to mind is that perhaps a server isn’t running? It could be missed. Some RPC servers are activated by some distinct action or <a href="https://docs.microsoft.com/en-us/windows/win32/services/service-trigger-events">trigger</a>. If an RPC server isn’t running, then <strong>RpcView is blind to it</strong>. The counter is that what you see is what you get. There is no mystery or time wasted trying to figure out how to trigger a RPC server, because it is already running.</p><p>Also, what about trying to <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCommon/Misc.c#L31">open a handle</a> to a process with a higher <a href="http://www.alex-ionescu.com/?p=97">PPL</a> than that of RpcView (even running as admin)? It wouldn’t be possible to open a handle to the process to analyze the runtime memory.</p><p>An advantage to reading some of the RPC data structures at runtime is that it has access to <a href="https://docs.microsoft.com/en-us/windows/win32/rpc/interface-registration-flags">interface registration flags</a> and authentication info for the server. Some of the RPC specific information is not directly available in the compiled binary, IDL, or ACF file. When the server registers an interface, it passes a flag to the Windows API<a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcserverregisterif2"><code class="language-plaintext highlighter-rouge">RpcServerRegisterIf2</code></a>. The registration flags configure the RPC server at runtime.</p><p><img data-src="/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/rpcview-authinfo-registation-flags.png" alt="rpcview-auth-reg" class="shadow" data-proofer-ignore><em>RpcView AuthInfo (top) Registration Flags (bottom) GUI</em></p><p><strong>No other tool analyzed provides this information</strong>. This is helpful when trying to understand the connection requirements for a client binding to the server.</p><h3 id="ntobjectmanager"><span class="mr-2">NtObjectManager</span><a href="#ntobjectmanager" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/ntobjectmanager-github.png" alt="ntobjectmanager-github" class="shadow" data-proofer-ignore><em>NtObjectManager</em></p><p><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/main/NtObjectManager">NtObjectManager</a> is the PowerShell module that exposes several RPC discovery methods (such as <code class="language-plaintext highlighter-rouge">Get-RpcServer</code>) (backed by its supporting .NET managed library <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/tree/main/NtApiDotNet">NtApiDotNet</a>). <em>NtObjectManager</em> goes about discovering RPC servers (and even clients) a bit differently. It does not look directly at running processes, but rather it will parse a list of PE files that you feed it to attempt to discover if the binary is an RPC server. It will then load each of those PE files and parse NDR data structures (think <code class="language-plaintext highlighter-rouge">_RPC_SERVER_T</code> and <code class="language-plaintext highlighter-rouge">_RPC_INTERFACE_T</code> from RpcView) found with the data section of RPC compiled binaries. From the data structures the RPC <em>interfaces</em>, <em>endpoints</em>, and <em>procedures</em> can also be discovered as in RpcView.</p><h4 id="code-1"><span class="mr-2">Code</span><a href="#code-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote><p>Source: https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools</p></blockquote><p>The starting point for RPC server enumeration is the <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/067c7581fdbaca482525063ad73ef0d134598cff/NtObjectManager/RpcFunctions.ps1#L253"><code class="language-plaintext highlighter-rouge">Get-RpcServer</code></a> powershell <a href="https://docs.microsoft.com/en-us/powershell/scripting/developer/cmdlet/cmdlet-overview?view=powershell-7.2#:~:text=A%20cmdlet%20is%20a%20lightweight,them%20programmatically%20through%20PowerShell%20APIs.">cmdlet</a> that takes a list of binaries as input to parse as RPC server objects.</p><div class="language-powershell highlighter-rouge"><div class="code-header"> <span data-label-text="Powershell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c"># Find all servers in SYSTEM32. </span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="nx">C:\Users\user</span><span class="err">&gt;</span><span class="w"> </span><span class="nv">$rpc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ls</span><span class="w"> </span><span class="s2">"C:\Windows\system32\*"</span><span class="w"> </span><span class="nt">-Include</span><span class="w"> </span><span class="s2">"*.dll"</span><span class="p">,</span><span class="s2">"*.exe"</span><span class="w"> </span><span class="se">`
</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="n">Get-RpcServer</span><span class="w">

</span></pre></table></code></div></div><p>For NT Object Manager:</p><blockquote><p>This command does a heuristic search in a DLL’s data sections for RPC servers and clients and parses the NDR structures. You can use this to generate RPC server definitions similar to RpcView (but in my own weird C# pseudo-code syntax) but for this scenario we only care about the clients.- <a href="https://www.tiraniddo.dev/2018/11/finding-windows-rpc-client.html">Finding Windows RPC Client Implementations Through…</a></p></blockquote><p>For each binary it calls out to the static method <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L271"><code class="language-plaintext highlighter-rouge">[NtApiDotNet.Win32.RpcServer]::ParsePeFile</code></a> within <em>NtApiDotNet</em>. This is where all the magic happens, or at least where it begins. You might want to grab a coffee before getting into this next section, or skip it entirely and check out the <a href="#summary">summary</a>. Otherwise, brace yourself.</p><p>The code path for RPC discovery via <code class="language-plaintext highlighter-rouge">[NtApiDotNet.Win32.RpcServer]::ParsePeFile</code> can be summarized as follows:</p><ol><li><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L271">LoadLibrary</a> - The first thing is a call to <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L274">LoadLibrary</a> on the supplied binary path (such as <em>C:\Windows\System32\lsass.exe</em>). This call is essentially a .NET wrapper (or <a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/interop/interoperability-overview">interop</a>) around the <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/SafeLoadLibraryHandle.cs#L1054">Win32 Native <code class="language-plaintext highlighter-rouge">LoadLibraryEx</code></a> that returns a <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/SafeLoadLibraryHandle.cs#L352">SafeLoadLibraryHandle</a> class type (which is a class that holds a reference to the loaded module with several useful <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/SafeLoadLibraryHandle.cs#L383">helper methods</a>). An interesting (and likely necessary for stability) flag passed to <code class="language-plaintext highlighter-rouge">LoadLibraryEx</code> here is <em>DONT_RESOLVE_DLL_REFERENCES</em>, which will prevent the <code class="language-plaintext highlighter-rouge">DllMain</code> from being called and further dependencies being loaded. Interestingly, MSDN <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibraryexa#:~:text=Do%20not%20use%20this%20value">tells us not to use it</a>, but it seems like it would serve the purpose of just loading the binary to get a handle to the module for data parsing no?<li><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/SafeLoadLibraryHandle.cs#L543">GetImageSections</a> - After the <code class="language-plaintext highlighter-rouge">SafeLoadLibraryHandle</code> type is created, <code class="language-plaintext highlighter-rouge">GetImageSections</code> is <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L282">called</a> to parse each <a href="https://docs.microsoft.com/en-us/cpp/build/reference/section-specify-section-attributes?view=msvc-170">section</a> of the loaded module. This is done via a call to the private method <code class="language-plaintext highlighter-rouge">SetupValues</code> responsible for building the list of <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/ImageSection.cs#L24"><em>ImageSections</em></a> assigned the private <code class="language-plaintext highlighter-rouge">SafeLoadLibraryHandle</code> class member <code class="language-plaintext highlighter-rouge">&lt;List&gt; _image_sections</code> <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/SafeLoadLibraryHandle.cs#L1587">here</a>.<li><p><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L435">FindRpcServerInterfaces</a> - Each image section (<code class="language-plaintext highlighter-rouge">.text</code>,<code class="language-plaintext highlighter-rouge">.data</code>,etc.) is then <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L283">passed</a> into <code class="language-plaintext highlighter-rouge">FindRpcServerInterfaces</code>. This call has a similar goal as the <code class="language-plaintext highlighter-rouge">GetRpcServerAddressInProcess</code> call in RpcView, that of searching for the root of <code class="language-plaintext highlighter-rouge">RPC_SERVER_T</code> data structure (pointed to at runtime by the <code class="language-plaintext highlighter-rouge">GlobalRpcServer</code> symbol). For <code class="language-plaintext highlighter-rouge">FindRpcServerInterfaces</code> the data structure is <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrNativeUtils.cs#L579"><code class="language-plaintext highlighter-rouge">RPC_SERVER_INTERFACE</code></a> and it discovers the data quite differently. Rather than looking for the <code class="language-plaintext highlighter-rouge">GlobalRpcServer</code> symbol within the <em>rpcrt4.dll</em> <code class="language-plaintext highlighter-rouge">.data</code> section at runtime, it discovers the data structure within the read-only data section (<code class="language-plaintext highlighter-rouge">.rdata</code>) memory section of the image it just loaded in step 1. It seems as though the base RPC data structure leading to interface, MIDL information, and all things RPC are available within the of the image on disk as well (AuthInfo excepted). <code class="language-plaintext highlighter-rouge">FindRpcServerInterfaces</code> <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L440">searches</a> through all loaded image memory sections for the <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrNativeUtils.cs#L135"><code class="language-plaintext highlighter-rouge">DCE_TransferSyntax</code></a> GUID. Once it is found, it returns a <code class="language-plaintext highlighter-rouge">IEnumerable&lt;RpcOffset&gt;</code> used in the next step.</p><p>Some other key differences from RpcView are that <code class="language-plaintext highlighter-rouge">FindRpcServerInterfaces</code>:</p><ul><li><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L440">searches</a> for an alternative <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rpce/dca648a5-42d3-432c-9927-2f22e50fa266"><code class="language-plaintext highlighter-rouge">NDR64_TransferSyntax</code></a> GUID <em>71710533-BEBA-4937-8319-B5DBEF9CCC36</em>. RpcView has code that will <a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcView/InterfacesWidget.cpp#L329">identify</a> it in the <code class="language-plaintext highlighter-rouge">InterfacesWidget::AddInterfaces</code> enhancing the GUI, but will not find it when identifying RPC servers. I wonder if any interfaces come up with the <em>NDR64</em> identifier?? I guess even if the <em>NDR64</em> syntax ID was found, it <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/5e00a851f88e735b95f059afd7e27e93f3b11752/NtApiDotNet/Ndr/NdrParser.cs#L338">can’t be fully parsed</a>.<li>doesn’t seem to be limited to the <code class="language-plaintext highlighter-rouge">.data</code> section, it looks at all sections (not sure if it matters though?). It’s only requirement is that the image section <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L437">be readable</a>.</ul><li><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L288">SymbolResolver.Create</a> - At this point, a new instance of a <code class="language-plaintext highlighter-rouge">SymboleResolver</code> is <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L288">created</a> to leverage the pdb symbols for the RPC server (if available). I won’t explain any details of this besides it depends on <code class="language-plaintext highlighter-rouge">dbghelp.dll</code> being installed and configured to work properly. It is used later to resolve or “<a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/5e00a851f88e735b95f059afd7e27e93f3b11752/NtApiDotNet/Ndr/NdrParser.cs#L289">fixup</a>” procedure names once they are identified.<li><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrParser.cs#L733">ReadFromRpcServerInterface</a> - Read out <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrNativeUtils.cs#L579"><em>RPC_SERVER_INTERFACE</em></a> from the <code class="language-plaintext highlighter-rouge">.rdata</code> image section in memory. For <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L295">each</a> of the found <code class="language-plaintext highlighter-rouge">RpcOffset</code>s from <code class="language-plaintext highlighter-rouge">FindRpcServerInterfaces</code> a <em>NdrParser</em> is <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L298">instantiated</a> and leveraged to parse out all of the interfaces and procedures. The <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrParser.cs#L143"><em>NdrParser</em></a> class calls <code class="language-plaintext highlighter-rouge">ReadFromRpcServerInterface</code> which in turn <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrParser.cs#L735">calls</a> its private method <code class="language-plaintext highlighter-rouge">ReadRpcServerInterface</code> that performs the rest of the work. On success, it returns a <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrRpcServerInterface.cs#L25"><code class="language-plaintext highlighter-rouge">NdrRpcServerInterface</code></a> that is used to finally generate an <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L32"><code class="language-plaintext highlighter-rouge">RpcServer</code></a> class to <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L304">add to the list</a> of RPC servers found.<li><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrParser.cs#L151">ReadRpcServerInterface</a> - Now we are in the thick of it. Within this method several things happen that for brevity (and hopefully not for lack of understanding) I will summarize.<ul><li><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrNativeUtils.cs#L591">GetDispatchTable</a> - This function reads the <em>RPC_DISPATCH_TABLE</em> struct <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrNativeUtils.cs#L584">referenced</a> within <em>RPC_SERVER_INTERFACE</em> needed to get a count of the number of procedures for the interface (<a href="https://github.com/silverf0x/RpcView/blob/66288f93663f91ede5143ce20fa556fb5cdcc3dc/RpcCore/RpcCore.c#L495">just like</a> RpcView).<li><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrParser.cs#L294">ReadProcs</a> - This method resolves all of the <em>procedures</em> relative to the identified interface and the <em>RPC_DISPATCH_TABLE</em> that contains the info needed to find the procedure offsets. It is within this function that all the procedures <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrProcedureDefinition.cs#L218">get their names</a> from the aforementioned <code class="language-plaintext highlighter-rouge">SymbolResolver</code>.<li><a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrNativeUtils.cs#L610">GetProtSeq</a> Reads out all the <em>endpoints</em> pointers and transforms each one into a new <code class="language-plaintext highlighter-rouge">NdrProtocolSequenceEndpoint</code> class that assigns the <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrProtocolSequenceEndpoint.cs#L37">protocol</a> and <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrProtocolSequenceEndpoint.cs#L38">endpoint</a>.<li><code class="language-plaintext highlighter-rouge">new NdrRpcServerInterface</code> - This call takes all of the parsed information and wraps it into a nice data structure <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Ndr/NdrRpcServerInterface.cs#L25"><code class="language-plaintext highlighter-rouge">NdrRpcServerInterface</code></a></ul></ol><div file="NtApiDotNet/Ndr/NdrRpcServerInterface.cs" class="language-c# highlighter-rouge"><div class="code-header"> <span data-label-text="NtApiDotNet/Ndr/NdrRpcServerInterface.cs"><i class="far fa-file-code"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">private</span> <span class="k">static</span> <span class="n">NdrRpcServerInterface</span> <span class="nf">ReadRpcServerInterface</span><span class="p">(</span><span class="n">IMemoryReader</span> <span class="n">reader</span><span class="p">,</span> <span class="n">RPC_SERVER_INTERFACE</span> <span class="n">server_interface</span><span class="p">,</span> 
    <span class="n">NdrTypeCache</span> <span class="n">type_cache</span><span class="p">,</span> <span class="n">ISymbolResolver</span> <span class="n">symbol_resolver</span><span class="p">,</span> <span class="n">NdrParserFlags</span> <span class="n">parser_flags</span><span class="p">,</span> <span class="n">IntPtr</span> <span class="n">base_address</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RPC_DISPATCH_TABLE</span> <span class="n">dispatch_table</span> <span class="p">=</span> <span class="n">server_interface</span><span class="p">.</span><span class="nf">GetDispatchTable</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">procs</span> <span class="p">=</span> <span class="nf">ReadProcs</span><span class="p">(</span><span class="n">reader</span><span class="p">,</span> <span class="n">server_interface</span><span class="p">.</span><span class="nf">GetServerInfo</span><span class="p">(</span><span class="n">reader</span><span class="p">),</span> <span class="m">0</span><span class="p">,</span> 
        <span class="n">dispatch_table</span><span class="p">.</span><span class="n">DispatchTableCount</span><span class="p">,</span> <span class="n">type_cache</span><span class="p">,</span> <span class="n">symbol_resolver</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="n">parser_flags</span><span class="p">,</span> <span class="n">base_address</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">NdrRpcServerInterface</span><span class="p">(</span><span class="n">server_interface</span><span class="p">.</span><span class="n">InterfaceId</span><span class="p">,</span> <span class="n">server_interface</span><span class="p">.</span><span class="n">TransferSyntax</span><span class="p">,</span> <span class="n">procs</span><span class="p">,</span>
        <span class="n">server_interface</span><span class="p">.</span><span class="nf">GetProtSeq</span><span class="p">(</span><span class="n">reader</span><span class="p">).</span><span class="nf">Select</span><span class="p">(</span><span class="n">s</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nf">NdrProtocolSequenceEndpoint</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">reader</span><span class="p">)));</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="thoughts-1"><span class="mr-2">Thoughts</span><a href="#thoughts-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>Well, one thought it that my head hurts. My venture into RPC enumeration tools has led me down paths of C++ and C# that I didn’t know I could travel. But as for <em>NtObjectManager</em> the tool and its RPC enumeration capability, I like it. It is trivial to discover all the RPC on a machine, both servers and <a href="https://github.com/googleprojectzero/sandbox-attacksurface-analysis-tools/blob/c02ed8ba04324e54a0a188ab9877ee6aa372dfac/NtApiDotNet/Win32/RpcServer.cs#L462">RPC clients alike</a>. One current downside is that it doesn’t seem to parse out any of the <em>AuthInfo</em> or registation flags as RpcView reports. On the other hand, it doesn’t miss an RPC servers or clients if they can be found on disk.</p><h3 id="rpcenum"><span class="mr-2">RPCEnum</span><a href="#rpcenum" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/rpcenum-github.png" alt="rpcenum" class="shadow" data-proofer-ignore><em>RpcEnum</em></p><p>This tool is <a href="https://blog.xpnsec.com/analysing-rpc-with-ghidra-neo4j">well described</a> by <em>@_xpn_</em>. It is based on an RpcView runtime discovery and enumeration strategy.</p><h4 id="code-2"><span class="mr-2">Code</span><a href="#code-2" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote><p>Source: https://github.com/xpn/RpcEnum</p></blockquote><p>The <a href="https://github.com/xpn/RpcEnum/blob/master/RpcEnum/RpcEnum/rpc.cpp#L101"><code class="language-plaintext highlighter-rouge">RPC::huntForGlobalRPCServer</code></a> function mimics RpcView’s search for <code class="language-plaintext highlighter-rouge">GlobalRpcServer</code>. The project it much easier to understand, more straight to the point and not littered with callbacks to QT like RpcView. In hind sight, I should have started here to better understand RpcView. Some nice features include the ability to <a href="https://github.com/xpn/RpcEnum/blob/master/RpcEnum/RpcEnum/RpcEnum.cpp#L62">dump JSON</a> files related to interfaces and their procedures as pointed out in the <a href="https://blog.xpnsec.com/analysing-rpc-with-ghidra-neo4j/">corresponding article</a>, the ability to graph all the things and find links between RPC calls and Win32 calls within RPC server binaries.</p><h3 id="rpcdump"><span class="mr-2">RPCDump</span><a href="#rpcdump" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/rpcdump-github.png" alt="rpcdump" class="shadow" data-proofer-ignore><em>RPCDump</em></p><p>This is a dynamic tool by <a href="https://twitter.com/0xcsandker">0xcsandker</a> that relies on an endpoint being registered by an RPC server via <a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcepregister"><code class="language-plaintext highlighter-rouge"> RpcEpRegister</code></a>. During an RPC server initialization, the server would have had to call this function to make it known to the endpoint mapper.</p><h4 id="code-3"><span class="mr-2">Code</span><a href="#code-3" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote><p>Source: https://github.com/csandker/RPCDump</p></blockquote><p>The code follows a path iterating through each endpoint in the RPC endpoint mapper.</p><blockquote><p>Another option is to query the Endpoint Manager directly by calling <a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin">RpcMgmtEpEltInqBegin</a> and iterating over the interfaces via <a href="https://docs.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcmgmtepeltinqnext">RpcMgmtEpEltInqNext</a>. <a href="https://csandker.io/2021/02/21/Offensive-Windows-IPC-2-RPC.html">0xcsandker</a></p></blockquote><p>One cool thing about the tool is that is adds <a href="https://github.com/csandker/RPCDump/blob/main/CPP-RPCDump/rpc_resolve.h#L4">known endpoints</a> to its analysis to enrich the information related to the outputs. . The known endpoints seem to be a collection known by the author from <a href="https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-efsr/ab3c0be4-5b55-4a08-b198-f17170100be6">various sources</a>.</p><div class="language-powershell highlighter-rouge"><div class="code-header"> <span data-label-text="Powershell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="nx">C:\Users\user\source\repos\RPCDump\x64\Debug</span><span class="err">&gt;</span><span class="w"> </span><span class="o">.</span><span class="nx">\CPP-RPCDump.exe</span><span class="w"> </span><span class="nx">localhost</span><span class="w">
</span><span class="c">## Testing protseq.: ncacn_ip_tcp</span><span class="w">

</span><span class="n">IfId:</span><span class="w"> </span><span class="nx">51a227ae-825b-41f2-b4a9-1ac9557a1018</span><span class="w"> </span><span class="nx">version</span><span class="w"> </span><span class="nx">1.0</span><span class="w">
</span><span class="n">Known</span><span class="w"> </span><span class="nx">Endpoint:</span><span class="w"> </span><span class="p">(</span><span class="n">C:\Windows\System32\keyiso.dll</span><span class="p">)</span><span class="o">.</span><span class="w">
</span><span class="n">Annotation:</span><span class="w"> </span><span class="nx">Ngc</span><span class="w"> </span><span class="nx">Pop</span><span class="w"> </span><span class="nx">Key</span><span class="w"> </span><span class="nx">Service</span><span class="w">
</span><span class="n">UUID:</span><span class="w"> </span><span class="nx">00000000-0000-0000-0000-000000000000</span><span class="w">
</span><span class="n">Binding:</span><span class="w"> </span><span class="nx">ncacn_ip_tcp:localhost</span><span class="p">[</span><span class="mi">49664</span><span class="p">]</span><span class="w">

</span><span class="n">IfId:</span><span class="w"> </span><span class="nx">367abb81-9844-35f1-ad32-98f038001003</span><span class="w"> </span><span class="nx">version</span><span class="w"> </span><span class="nx">2.0</span><span class="w">
</span><span class="n">Known</span><span class="w"> </span><span class="nx">Endpoint:</span><span class="w"> </span><span class="p">[</span><span class="n">MS</span><span class="nt">-SCMR</span><span class="p">](</span><span class="n">https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-scmr/19168537-40b5-4d7a-99e0-d77f0f5e0241</span><span class="p">)</span><span class="o">.</span><span class="w">
</span><span class="n">Annotation:</span><span class="w">
</span><span class="nx">UUID:</span><span class="w"> </span><span class="nx">00000000-0000-0000-0000-000000000000</span><span class="w">
</span><span class="n">Binding:</span><span class="w"> </span><span class="nx">ncacn_ip_tcp:localhost</span><span class="p">[</span><span class="mi">49671</span><span class="p">]</span><span class="w">

</span><span class="n">IfId:</span><span class="w"> </span><span class="nx">650a7e26-eab8-5533-ce43-9c1dfce11511</span><span class="w"> </span><span class="nx">version</span><span class="w"> </span><span class="nx">1.0</span><span class="w">
</span><span class="n">Known</span><span class="w"> </span><span class="nx">Endpoint:</span><span class="w"> </span><span class="p">(</span><span class="n">C:\Windows\System32\rascustom.dll</span><span class="p">)</span><span class="o">.</span><span class="w">
</span><span class="n">Annotation:</span><span class="w"> </span><span class="nx">Vpn</span><span class="w"> </span><span class="nx">APIs</span><span class="w">
</span><span class="n">UUID:</span><span class="w"> </span><span class="nx">00000000-0000-0000-0000-000000000000</span><span class="w">
</span><span class="n">Binding:</span><span class="w"> </span><span class="nx">ncacn_np:localhost</span><span class="p">[</span><span class="n">\\PIPE\\ROUTER</span><span class="p">]</span><span class="w">

</span><span class="n">IfId</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="n">f5f6521</span><span class="nt">-cb55-1059-b446-00df0bce31db</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="mf">1.0</span><span class="w">
</span><span class="n">Known</span><span class="w"> </span><span class="n">Endpoint</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="n">C:\Windows\System32\unimdm.tsp.</span><span class="w">
</span><span class="nx">Annotation:</span><span class="w"> </span><span class="nx">Unimodem</span><span class="w"> </span><span class="nx">LRPC</span><span class="w"> </span><span class="nx">Endpoint</span><span class="w">
</span><span class="n">UUID</span><span class="p">:</span><span class="w"> </span><span class="mi">00000000</span><span class="nt">-0000-0000-0000-000000000000</span><span class="w">
</span><span class="n">Binding</span><span class="p">:</span><span class="w"> </span><span class="n">ncacn_np</span><span class="p">:</span><span class="n">localhost</span><span class="p">[</span><span class="n">\\pipe\\tapsrv</span><span class="p">]</span><span class="w">

</span><span class="n">IfId</span><span class="p">:</span><span class="w"> </span><span class="mi">12345678</span><span class="nt">-1234-abcd-ef00-0123456789ab</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="mf">1.0</span><span class="w">
</span><span class="n">Known</span><span class="w"> </span><span class="n">Endpoint</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="n">MS</span><span class="nt">-RPRN</span><span class="p">](</span><span class="n">https</span><span class="p">:</span><span class="n">//docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/e8f9dad8-d114-41cc-9a52-fc927e908cf4</span><span class="p">)</span><span class="o">.</span><span class="w">
</span><span class="n">Annotation</span><span class="p">:</span><span class="w">
</span><span class="n">UUID</span><span class="p">:</span><span class="w"> </span><span class="mi">00000000</span><span class="nt">-0000-0000-0000-000000000000</span><span class="w">
</span><span class="n">Binding</span><span class="p">:</span><span class="w"> </span><span class="n">ncacn_ip_tcp</span><span class="p">:</span><span class="n">localhost</span><span class="p">[</span><span class="mi">49669</span><span class="p">]</span><span class="w">

</span></pre></table></code></div></div><h3 id="impacket---rpcdumppy"><span class="mr-2">Impacket - rpcdump.py</span><a href="#impacket---rpcdumppy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/impacket-github.png" alt="impacket" class="shadow" data-proofer-ignore><em>impacket - rpcdump.py</em></p><p>Nothing but good things to say about the <a href="https://github.com/SecureAuthCorp/impacket">impacket</a> python library allowing fine grained control of packets for various network protocols. When learning how to use NtObjectManager exercising Petitpotam, I used <a href="https://twitter.com/topotam77">@topotam77</a>’s <a href="https://github.com/topotam/PetitPotam/blob/main/PetitPotam.py">PetitPotam.py</a> python implementation leveraging impacket as a control to make sure I understood the expected behavior for Petitpotam. This led to my blog post <a href="https://clearbluejar.github.io/posts/from-ntobjectmanager-to-petitpotam/">From NtObjectManager to PetitPotam</a>.</p><h4 id="code-4"><span class="mr-2">Code</span><a href="#code-4" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><blockquote><p>https://github.com/SecureAuthCorp/impacket/blob/master/examples/rpcdump.py</p></blockquote><p>The script, <a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/rpcdump.py">rpcdump.py</a> is another tool that relies on the endpoint mapper having a registered endpoint from an RPC server. It also has the benefit of combining <a href="https://github.com/SecureAuthCorp/impacket/blob/cd4fe47cfcb72d7d35237a99e3df95cedf96e94f/impacket/dcerpc/v5/epm.py">known endpoints</a> with the RPC enumeration results to provide more information.</p><h3 id="ghidra"><span class="mr-2">Ghidra</span><a href="#ghidra" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p><img data-src="/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/ghidra.png" alt="ghidra" class="shadow" style="max-width: 90%" data-proofer-ignore><em>Ghidra</em></p><p>Ah <a href="https://github.com/NationalSecurityAgency/ghidra">Ghidra</a>, the most cost effective SRE tool on the market. It doesn’t have any native RPC discovery or enumeration functionality that I am aware of, but it is often used in combination with the aforementioned tools to provide insight into RPC through <a href="https://blog.xpnsec.com/analysing-rpc-with-ghidra-neo4j/#:~:text=throw%20that%20into-,Ghidra,-to%20see%20how">reverse engineering</a> or used as a part of suite of tools used to <a href="https://blog.xpnsec.com/analysing-rpc-with-ghidra-neo4j">map Windows RPC calls to native Win32 APIs</a>. <em>@_xpn_</em> also provided a <a href="https://github.com/xpn/RpcEnum/blob/master/post_script.py#L32">Ghidra python script</a> that would leverage the JSON output from <em>RpcEnum</em> to discover the RPC procedures in binaries and then recursively dump the functions called by each procedure.</p><h4 id="winrpcfunctions"><span class="mr-2">WinRpcFunctions</span><a href="#winrpcfunctions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p><img data-src="/assets/img/2022-06-02-surveying-windows-rpc-discovery-tools/winrpcfunctions-github.png" alt="winrpcfunctions-github" class="shadow" data-proofer-ignore><em>WinRpcFunctions</em></p><p>Another article <a href="https://medium.com/threat-hunters-forge/extending-the-exploration-and-analysis-of-windows-rpc-methods-calling-other-functions-with-ghidra-e4cdaa9555bd">Extending the Exploration and Analysis of Windows RPC Methods Calling other Functions with Ghidra, Jupyter Notebooks and Graphframes</a> by <a href="https://twitter.com/Cyb3rWard0g">@Cyb3rWard0g</a> built on <em>xpn</em>’s work.</p><h5 id="code-5"><span class="mr-2">Code</span><a href="#code-5" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h5><blockquote><p>Source: https://github.com/Cyb3rWard0g/WinRpcFunctions</p></blockquote><p>The researcher put both RPC <a href="https://github.com/Cyb3rWard0g/WinRpcFunctions/blob/master/resources/scripts/FindWinRpcFunctionsMaps.java#L164-L236">enumeration</a> and <em>xpn</em>’s <a href="https://github.com/Cyb3rWard0g/WinRpcFunctions/blob/master/resources/scripts/FindWinRpcFunctionsMaps.java#L49-L83">recursive function discovery</a> into a single Ghidra script. The script could then map all RPC functions to Windows API calls within various RPC servers on disk. Using the script, RPC enumeration and discovery can be performed in Ghidra with it’s ability to analyze binaries and enriched with PDB symbols. Due to the fact that each binary needs to be analyzed in Ghidra for the script to function, it can take quite a bit of time. To narrow down analysis to only RPC servers, <em>Cyb3rWard0g</em> leverages <em>NtObjectManager</em> initially to identify and generate the list of RPC servers to avoid analyzing more binaries than necessary. For further details on this cool idea check out the <a href="https://medium.com/threat-hunters-forge/extending-the-exploration-and-analysis-of-windows-rpc-methods-calling-other-functions-with-ghidra-e4cdaa9555bd">blog post</a>.</p><h3 id="summary"><span class="mr-2">Summary</span><a href="#summary" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3><p>It turns out there are several available tools to discover RPC on a Windows machine. I know I have not exhausted the list, but perhaps I came close. Each tool and technique has their own advantages and disadvantages. Here is a best effort on a summary.</p><div class="table-wrapper"><table><thead><tr><th>Tool<th>Type<th>Pros<th>Cons<th>Requirements<th>Language<tbody><tr><td>RpcView<td>Dynamic<td>GUI, AuthInfo<td>Misses RPC clients and dormant servers<td>RPC Server Running<td>C++<tr><td>NtObjectManager<td>Static<td>PS + Speed + Filtering + Clients<td>No AuthInfo<td>RPC Server Path Known<td>PS,C#<tr><td>RpcEnum<td>Dynamic<td>JSON Output<td>Misses RPC clients and dormant servers<td>RPC Server Running<td>C++<tr><td>RpcDump<td>Dynamic<td>Well-Known Endpoints<td>Blind to unregistered endpoints<td> <td>C++<tr><td>Impacket - rpcdump<td>Dynamic<td>Well-Known Endpoints<td> <td> <td>Python<tr><td>WinRpcFunctions<td>Static<td>Ghidra only<td>Slow<td>RPC Server Path Known<td>Java</table></div><h4 id="when-to-use-which-tool"><span class="mr-2">When to use which tool?</span><a href="#when-to-use-which-tool" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4><p>The answer to this question is “it depends”.</p><div class="table-wrapper"><table><thead><tr><th>RPC Purpose<th>Tools<th>Reason<tbody><tr><td>Trying to figure out client connection requirements<td>RpcView<td>Availability of AuthInfo<tr><td>Dynamically looking at running RPC servers<td>RpcView<td>Easy to navigate across interfaces and click around<tr><td>Looking for RPC clients<td>NtObjectManager<td>Ony tool that finds them?<tr><td>Trying to find all RPC servers on a machine<td>NtObjectManager<td>RPC server doesn’t have to be running<tr><td>Testing an RPC interface<td>NtObjectManager<td>Builds RPC clients on the fly<tr><td>Developing the next PetitPotam<td>impacket<td>low level control of RPC transport protocols</table></div><p>That’s all for now. The next post will be an in depth walkthrough of using NtObjectManager to discover the well known PetotPotam.</p><p>Please reach out <a href="https://twitter.com/clearbluejar">@clearbluejar</a> with questions or comments. Also appreciate any <a href="https://github.com/clearbluejar/clearbluejar.github.io/issues/new?assignees=&amp;labels=&amp;template=post-feedback.md&amp;title=%5BFeedback%5D%20A%20Survey%20of%20Windows%20RPC%20Discovery%20Tools">feedback or corrections</a> you might have for the post.</p><hr /><p><sub>Cover photo by Todd Quackenbush on Unsplash</sub></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/windows/'>windows</a>, <a href='/categories/rpc/'>rpc</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/rpcdump/" class="post-tag no-text-decoration" >rpcdump</a> <a href="/tags/rpcview/" class="post-tag no-text-decoration" >rpcview</a> <a href="/tags/ntobjectmanager/" class="post-tag no-text-decoration" >ntobjectmanager</a> <a href="/tags/impacket/" class="post-tag no-text-decoration" >impacket</a> <a href="/tags/ntlmrelay/" class="post-tag no-text-decoration" >NTLMrelay</a> <a href="/tags/rpc/" class="post-tag no-text-decoration" >rpc</a> <a href="/tags/windows/" class="post-tag no-text-decoration" >windows</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=A+Survey+of+Windows+RPC+Discovery+Tools+-+clearbluejar&url=https%3A%2F%2Fclearbluejar.github.io%2Fposts%2Fsurveying-windows-rpc-discovery-tools%2F" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=A+Survey+of+Windows+RPC+Discovery+Tools+-+clearbluejar&u=https%3A%2F%2Fclearbluejar.github.io%2Fposts%2Fsurveying-windows-rpc-discovery-tools%2F" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https%3A%2F%2Fclearbluejar.github.io%2Fposts%2Fsurveying-windows-rpc-discovery-tools%2F&text=A+Survey+of+Windows+RPC+Discovery+Tools+-+clearbluejar" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" data-title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">Recently Updated</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/from-ntobjectmanager-to-petitpotam/">From NtObjectManager to PetitPotam</a><li><a href="/posts/introducing-cve-markdown-charts-part-1/">Introducing CVE Markdown Charts - Part 1</a><li><a href="/posts/mining-google-chrome-cve-data/">Mining Google Chrome CVE data</a><li><a href="/posts/surveying-windows-rpc-discovery-tools/">A Survey of Windows RPC Discovery Tools</a><li><a href="/posts/these-are-your-first-steps/">These Are Your First Steps</a></ul></div><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cve/">cve</a> <a class="post-tag" href="/tags/graphs/">graphs</a> <a class="post-tag" href="/tags/ntlmrelay/">NTLMrelay</a> <a class="post-tag" href="/tags/ntobjectmanager/">ntobjectmanager</a> <a class="post-tag" href="/tags/rpc/">rpc</a> <a class="post-tag" href="/tags/rpcview/">rpcview</a> <a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/charts/">charts</a> <a class="post-tag" href="/tags/chrome/">chrome</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">Contents</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div id="tail-wrapper" class="col-12 col-lg-11 col-xl-9 pl-3 pr-3 pr-xl-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/from-ntobjectmanager-to-petitpotam/"><div class="card-body"> <em class="small" data-ts="1656042360" data-df="ll" > Jun 24, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>From NtObjectManager to PetitPotam</h3><div class="text-muted small"><p> TL;DR - Windows RPC enumeration, discovery, and auditing via NtObjectManager. We will audit the vulnerable RPC interfaces that lead to PetitPotam, discover how they have changed over the past year,...</p></div></div></a></div><div class="card"> <a href="/posts/cve-north-stars/"><div class="card-body"> <em class="small" data-ts="1661856480" data-df="ll" > Aug 30, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Introducing CVE North Stars</h3><div class="text-muted small"><p> TL;DR - CVE North Stars is a tutorial that introduces a method to kickstart vulnerability research by treating CVEs as North Stars in vulnerability discovery and comprehension. Background Thi...</p></div></div></a></div><div class="card"> <a href="/posts/mining-google-chrome-cve-data/"><div class="card-body"> <em class="small" data-ts="1652819880" data-df="ll" > May 17, 2022 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Mining Google Chrome CVE data</h3><div class="text-muted small"><p> TL;DR - The Google Chrome Releases blog provides CVE data one liners containing all the information needed to create a rich CVE data source. Google Chrome CVEs are plentiful and provide informat...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/mining-google-chrome-cve-data/" class="btn btn-outline-primary" prompt="Older"><p>Mining Google Chrome CVE data</p></a> <a href="/posts/from-ntobjectmanager-to-petitpotam/" class="btn btn-outline-primary" prompt="Newer"><p>From NtObjectManager to PetitPotam</p></a></div></div></div><footer class="row pl-3 pr-3"><div class="col-12 d-flex justify-content-between align-items-center text-muted pl-0 pr-0"><div class="footer-left"><p class="mb-0"> © 2022 <a href="https://twitter.com/clearbluejar">clearbluejar</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">Trending Tags</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cve/">cve</a> <a class="post-tag" href="/tags/graphs/">graphs</a> <a class="post-tag" href="/tags/ntlmrelay/">NTLMrelay</a> <a class="post-tag" href="/tags/ntobjectmanager/">ntobjectmanager</a> <a class="post-tag" href="/tags/rpc/">rpc</a> <a class="post-tag" href="/tags/rpcview/">rpcview</a> <a class="post-tag" href="/tags/blog/">blog</a> <a class="post-tag" href="/tags/c/">C#</a> <a class="post-tag" href="/tags/charts/">charts</a> <a class="post-tag" href="/tags/chrome/">chrome</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); /* fix mermaid failing to render without refresh */ const toggle = new ModeToggle(); toggle.notify(); /* end fix */ }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a><div id="notification" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-animation="true" data-autohide="false"><div class="toast-header"> <button type="button" class="ml-2 ml-auto close" data-dismiss="toast" aria-label="Close"> <span aria-hidden="true">&times;</span> </button></div><div class="toast-body text-center pt-0"><p class="pl-2 pr-2 mb-3">A new version of content is available.</p><button type="button" class="btn btn-primary" aria-label="Update"> Update </button></div></div><script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result found.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/en.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-QR0Y2106CS"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-QR0Y2106CS', {'cookie_expires': 0 }); }); </script>
