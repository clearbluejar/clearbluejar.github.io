---
layout: post
title: "Patch Tuesday Diffing: CVE-2024-20696 - Windows Libarchive RCE"
date: 2024-03-11 04:45 +0000
description: Patch Diffing CVE-2024-20696 Windows Libarchive Remote Code Execution Vulnerability
image:
  path: /assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/patch-tuesday-diffing-cve-2024-20696.png
  src: /assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/patch-tuesday-diffing-cve-2024-20696.png
  lqip: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAFCAYAAAB8ZH1oAAAAAklEQVR4AewaftIAAACXSURBVE3BQWrDMBBA0T+asY1tsO5gX6BQ6H0DgYZ0H3qfZtV2aWikkew0u7wnry9v+zD0iATWdWXbNqYYObwfeRARVBWb4sSyzKSUMVPMjJ/vX0IIPHjO1FqxcRyZl5mubblcPtGg1Fph3/FSaLuO298Nu35dOZ8+eDbFCCKoKu4OAvaPfugRhJQSpRQ0BMwMzxl3p2ka7t70N478rgwUAAAAAElFTkSuQmCC
  alt: CVE-2024-20696 - Windows Libarchive RCE
category:
  - patchtuesday
  - CVE-2024-20696
tags:
  - CVE-2024-20696
  - CVE-2024-20697
  - RCE
  - windows
mermaid: true
---

TL;DR This post will teach you how to patch diff [CVE-2024-20696](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2024-20696) (and indirectly [CVE-2024-20697](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2024-20697)) from the [January 2024 Patch Tuesday](https://msrc.microsoft.com/update-guide/releaseNote/2024-Jan). This security patch was interesting as it wasn't fixing native Microsoft software per se, rather patching an open-source library [libarchive](https://github.com/libarchive/libarchive) used by Windows to support compression and decompression functionality. 

---

> Patch diffing is a powerful technique to start to understand modern complex vulnerabilities. It allows you to go and [see for yourself](https://cve-north-stars.github.io/docs/Conclusion#patch-diff-in-the-dark) what has changed about a binary without relying on external sources. To progress from knowing about a CVE to actually understanding its root cause.  *Patch Tuesday Diffing* is a series of posts meant to show you something interesting or fun about a recent CVE from Microsoft's Patch Tuesday.  Sometimes we will skim the surface, other times we will dig deep, but each time we will at least try to learn something new. There are [many reasons](https://cve-north-stars.github.io/docs/Patch-Diffing#benefits) why you want to learn the skill of patch diffing. Hopefully, this post or another from the series inspires you to give it a go.

---

According to the Register, Microsoft provided native support to extract `.rar`, `.7z`, `.gz` archive formats last summer. 

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/register-libarchive.png){: .shadow }_The Register announcing new compression formats supported by libarchive_

> Microsoft has signaled it will add native support for tar, 7-zip, rar, gz and "many other" archive file formats to Windows. Redmond's not cooked up some super-duper decompressor: it's used the [libarchive](https://www.libarchive.org/) open source project to pull this off. 
> [Source](https://www.theregister.com/2023/05/24/microsoft_rar_support_native_windows)

A quick look at the exports for libarchive from 2018 Windows 10 1809 seems to suggest that they have been using libarchive seems to have supported the "new" formats much sooner.

**Exports from archiveint.dll from Windows 1809 circa 2018**:

```bash
% wget https://msdl.microsoft.com/download/symbols/archiveint.dll/D36DF6F786000/archiveint.dll  -O archiveint.dll.x86.3.3.2
% objdump --all-headers archiveint.dll.x86.3.3.2 | grep _rar
     311  0x3ab00  _archive_read_support_format_rar@4
% objdump --all-headers archiveint.dll.x86.3.3.2 | grep gz
     275  0x269e0  _archive_read_support_compression_gzip@4
     288  0x269f0  _archive_read_support_filter_gzip@4
     331  0x4c1e0  _archive_write_add_filter_gzip@4
     371  0x4c1c0  _archive_write_set_compression_gzip@4
% objdump --all-headers archiveint.dll.x86.3.3.2 | grep 7z
     300  0x28d80  _archive_read_support_format_7zip@4
     379  0x4d910  _archive_write_set_format_7zip@4
```

Although they did seem to add a new `rar` related functionality version for Windows `archiveint.dll` 10.0.22621.2199 which was available August 2023:

```diff 
% objdump --all-headers archiveint.dll.x64.3.6.2 | grep _rar     
	 318  0xccc70  archive_read_support_format_rar
+    319  0xd10d0  archive_read_support_format_rar5
```

Regardless of when this support was available, it is here now. Microsoft provides an internally built version of the open-source project. Leveraging open-source is a good move, but as with all Windows software, **with a great customer base comes great responsibility.** 

Microsoft's internally built libarchive isn't exactly the same as the Windows binary [released](https://github.com/libarchive/libarchive/releases/tag/v3.5.2) by _libarchive_, but it is [close](https://gist.github.com/clearbluejar/5a88e10e58749fdd1288f8f4205caa85#diff-stats:~:text=func_match_overall_percent). 

**Ghidra PE Meta Data Showing A Similiar Number of Functions**
```diff
--- archiveint.dll.x64.10.0.19041.3636 Meta
+++ github-3.5.2.archive.dll Meta
@@ -1,44 +1,30 @@
-Program Name: archiveint.dll.x64.10.0.19041.3636
+Program Name: github-3.5.2.archive.dll
 Language ID: x86:LE:64:default (3.0)
 Compiler ID: windows
 Processor: x86
 Endian: Little
 Address Size: 64
 Minimum Address: 180000000
 Maximum Address: ff0000184f
-# of Bytes: 694896
-# of Memory Blocks: 10
-# of Instructions: 131686
-# of Defined Data: 5792
-# of Functions: 1778
-# of Symbols: 15300
-# of Data Types: 301
-# of Data Type Categories: 18
+# of Bytes: 904296
+# of Memory Blocks: 9
+# of Instructions: 168608
+# of Defined Data: 10021
+# of Functions: 1751
+# of Symbols: 14925
+# of Data Types: 288
+# of Data Type Categories: 19
 Analyzed: true
 Compiler: visualstudio:unknown
 Created With Ghidra Version: 11.0.1
 Executable Format: Portable Executable (PE)
```

Let's figure out what was changed for Microsoft's version of _libarchive_ for this CVE.  There are actually two components that make up _libarchive_ in Windows. Both `tar.exe` (which aligns to the open-source `bsdtar.exe`) and `archiveint.dll` (which is libarchive's `archive.dll`) . Only `archiveint.dll` was updated for this CVE so we are ignoring `tar.exe`.  

## Patch Diffing CVE-2024-20696

The first thing I like to do when patch diffing a CVE is to do a quick check to see what other CVEs might relate. 

Here is the history of libarchive from MSRC's list of CVEs:

| cve                                                                                     | Title              | Initial Release | CVSS | Impact                | KB Ver Type                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| --------------------------------------------------------------------------------------- | ------------------ | --------------- | ---- | --------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [CVE-2024-20696](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2024-20696) | Windows Libarchive | 2024-01-09      | 7.3  | Remote Code Execution | <details>[KB5034121](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5034121)-10.0.22000.2713-Security Update<br>[KB5034122](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5034122)-10.0.19044.3930-Security Update<br>[KB5034122](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5034122)-10.0.19045.3930-Security Update<br>[KB5034123](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5034123)-10.0.22621.3007-Security Update<br>[KB5034123](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5034123)-10.0.22631.3007-Security Update<br>[KB5034127](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5034127)-10.0.17763.5329-Security Update<br>[KB5034129](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5034129)-10.0.20348.2227-Security Update<br>[KB5034130](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5034130)-10.0.25398.643-Security Update</details> |
| [CVE-2024-20697](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2024-20697) | Windows Libarchive | 2024-01-09      | 7.3  | Remote Code Execution | <details>[KB5034123](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5034123)-10.0.22621.3007-Security Update<br>[KB5034123](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5034123)-10.0.22631.3007-Security Update<br>[KB5034130](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5034130)-10.0.25398.643-Security Update</details>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| [CVE-2021-36976](https://msrc.microsoft.com/update-guide/en-US/advisory/CVE-2021-36976) | Libarchive         | 2022-01-11      | 0    | Remote Code Execution | <details>[KB5009543](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5009543)-10.0.19042.1466-Security Update<br>[KB5009543](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5009543)-10.0.19043.1466-Security Update<br>[KB5009543](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5009543)-10.0.19044.1466-Security Update<br>[KB5009545](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5009545)-10.0.18363.2037-Security Update<br>[KB5009555](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5009555)-10.0.20348.469-Security Update<br>[KB5009557](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5009557)-10.0.17763.2452-Security Update<br>[KB5009566](https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB5009566)-10.0.22000.434-Security Update</details>                                                                                                                       |

 You can do a [quick search](https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=libarchive) in the MITRE CVE database to get an idea of common problems as well. Seems like the open-source *libarchive* had a use-after-free fixed in [CVE-2021-36976](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-36976) issue back in 2021.  This CVE was Microsoft updating libarchive to a new version with the patch. Perhaps this is what is happening for CVE-2024-20696?

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/msrc-cve-2021-36976.png){: .shadow }_FAQ providing more detail for CVE-2021-36976_

Let's see what CVE-2024-20696 is all about. 
### Requirements

For every patch diff you will need two binaries to compare.

Specifically, you need:

> - vulnerable binary
> - patched binary
> - SRE tooling
> - symbol information (if available)
> 
> [CVE North Stars](https://cve-north-stars.github.io/docs/Security-Patches#finding-the-binaries-to-compare)

## Identifying the Binaries

One approach to [finding which binary matches a CVE](https://cve-north-stars.github.io/docs/Security-Patches#finding-the-binaries-to-compare) is to use the *CVE description* to try and work it out.  You can also rely on your past experience, a blog post, or some other insights but for this CVE the description is enough. 

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/msrc-cve-2024-20696-libarchive.png){: .shadow }_MSRC's Security Update Guide - Windows Libarchive RCE_

Assuming you didn't already know the binary was `archiveint.dll`, we can use the keyword "libarchive" from the description and find a binary with a similar description. If you search through  [PE](https://learn.microsoft.com/en-us/windows/win32/debug/pe-format) binaries in System32, you will eventually find a matching description, or at least one that mentions libarchive. 

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/archiveint-dll-properties.png){: .shadow }_archiveint.dll Properties match CVE Description_

Another indicator that this binary is the one you are looking for is that it was updated for the   January 2024 Patch Tuesday. The version 10.22621.3007 from the PE image matches the build for [ January 9, 2024—KB5034123](https://support.microsoft.com/en-us/topic/january-9-2024-kb5034123-os-builds-22621-3007-and-22631-3007-3f7e169f-56e8-4e6e-b6b8-41f4aa4b9b88) .
## Downloading The Vulnerable and Patched Version

For Windows OS files there is no better resource than [Winbindex](https://winbindex.m417z.com/?file=archiveint.dll) when you want to download  specific binaries. To make things a bit easier though, just use the [wget command](https://gist.github.com/clearbluejar/538f86dc735fe9af5bbd568f3dbc3440#download-original-pes) to get the files.

```bash
wget https://msdl.microsoft.com/download/symbols/archiveint.dll/E9509ED1AD000/archiveint.dll -O ghidriffs/archiveint.dll.x64.10.0.19041.3636
wget https://msdl.microsoft.com/download/symbols/archiveint.dll/C9506245ad000/archiveint.dll -O ghidriffs/archiveint.dll.x64.10.0.19041.3930
```

## Patch Diffing Using Ghidriff

There are [many tools](https://clearbluejar.github.io/posts/ghidriff-ghidra-binary-diffing-engine/#history) that perform patch diffing. For the "Patch Diffing Tuesday" series, we will try multiple tools to see what we can learn from each. For the first post in the series, we will use `ghidriff`. `ghidriff` is a command-line patch diffing tool that leverages Ghidra's powerful programming API and has some (self-proclaimed) amazing features for automating patch diffing. Full disclosure, I wrote this tool to enhance my vulnerability research and to understand patch diffing at a deeper level. If you want to learn more check out the [repo](https://github.com/clearbluejar/ghidriff) or read this detailed [post](https://clearbluejar.github.io/posts/ghidriff-ghidra-binary-diffing-engine/) explaining its origin and features. 

For now, let's see the output from comparing the two binaries. Run `ghidriff` on the command line after downloading the vulnerable and patched binaries.

```bash
ghidriff archiveint.dll.x64.10.0.19041.3636 archiveint.dll.x64.10.0.19041.3930
``````

---
### Ghidriff in a Box (Docker) 

Alternatively, for those allergic to Ghidra and Java, you can just try the diff using [the *docker* image](https://github.com/clearbluejar/ghidriff/pkgs/container/ghidriff). 

```bash
mkdir -p ghidriffs
wget https://msdl.microsoft.com/download/symbols/archiveint.dll/E9509ED1AD000/archiveint.dll -O ghidriffs/archiveint.dll.x64.10.0.19041.3636
wget https://msdl.microsoft.com/download/symbols/archiveint.dll/C9506245ad000/archiveint.dll -O ghidriffs/archiveint.dll.x64.10.0.19041.3930
docker run -it --rm -v $(pwd)/ghidriffs:/ghidriffs ghcr.io/clearbluejar/ghidriff ghidriffs/archiveint.dll.x64.10.0.19041.3636 ghidriffs/archiveint.dll.x64.10.0.19041.3930
```


---
Check out the console output [here](https://gist.github.com/clearbluejar/b733ce20947b1c92a85bbc6a33fabaec).

Whether you use the command line, or a docker container, when `ghidriff` is complete you will have a "ghidriffs" directory that looks like this:

```bash
% tree -L 2 ghidriffs
ghidriffs
├── archiveint.dll.x64.10.0.19041.3636
├── archiveint.dll.x64.10.0.19041.3636-archiveint.dll.x64.10.0.19041.3930.ghidriff.md
├── archiveint.dll.x64.10.0.19041.3930
├── ghidra_projects
│   └── ghidriff-archiveint.dll.x64.10.0.19041.3636-archiveint.dll.x64.10.0.19041.3930
├── ghidriff.log
├── json
│   └── archiveint.dll.x64.10.0.19041.3636-archiveint.dll.x64.10.0.19041.3930.ghidriff.json
└── symbols
    ├── 000admin
    ├── archiveint.pdb
    └── pingme.txt
```

`ghidriff` creates a new Ghidra project, imports and analyzes the binaries, and then finally outputs the diff and resulting json. The resulting diff can be viewed as a Github gist [`archiveint.dll.x64.10.0.19041.3636-archiveint.dll.x64.10.0.19041.3930.ghidriff.md`](https://gist.github.com/clearbluejar/538f86dc735fe9af5bbd568f3dbc3440) 
### Reviewing Results

The markdown output looks like this: 

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/ghidriff-cve-2024-20696.png){: .shadow }_archiveint.dll `ghidriff` markdown in vscode_

When starting to review the results for a diff you walk through the *added*, *deleted*, and *modified* functions to see if something "pops out". 

#### Added / Deleted

In this case, there are several added functions. Most of the functions start with `wil_*` which is a reference to the  [Windows Instrumentation Library](https://github.com/microsoft/wil) I assumed often used by Microsoft devs. The  several `wil_*` functions (referenced here) are value add to libarchive standard open-source build to enable some telemetry from within _libarchive_ (previously this functionality didn't exist).

**Added NTQueryStateData**:

```c
undefined8
wil_details_NtQueryWnfStateData
          (undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,
          undefined8 param_5,undefined8 param_6)

{
  undefined8 uVar1;
  
  if (g_wil_details_pfnNtQueryWnfStateData == (FARPROC)0x0) {
    if (g_wil_details_ntdllModuleHandle == (HMODULE)0x0) {
      g_wil_details_ntdllModuleHandle = GetModuleHandleW(L"ntdll.dll");
    }
    g_wil_details_pfnNtQueryWnfStateData =
         GetProcAddress(g_wil_details_ntdllModuleHandle,"NtQueryWnfStateData");
    if (g_wil_details_pfnNtQueryWnfStateData == (FARPROC)0x0) {
      return 0xc0000139;
    }
  }
  uVar1 = (*g_wil_details_pfnNtQueryWnfStateData)(param_1,0,0,param_4,param_5,param_6);
  return uVar1;
}
```

The `wil_details_NtQueryWngStateData` [function](https://gist.github.com/clearbluejar/538f86dc735fe9af5bbd568f3dbc3440#wil_details_ntquerywnfstatedata) added in the patched `archiveint.dll` dynamically sets a function pointer to [NtQueryStateData](https://chromium.googlesource.com/external/github.com/DynamoRIO/drmemory/+/refs/heads/master/wininc/ntexapi.h#276) at runtime perhaps to avoid to a compile time link dependency to libarchive (just guessing). For more information about WNF or Windows Notification Facility check out this awesome post [Introducing Windows Notification Facility’s (WNF) Code Integrity](https://blog.trailofbits.com/2023/05/15/introducing-windows-notification-facilitys-wnf-code-integrity/) for some background. For out case this is likely enabling telemetry for this binary.  

The diff also reveals that new [feature](https://msft.chat/wiki/windows-feature-store.html) was added to `archiveint.dll`. Features are often added to recently patched code so that they can be enable and disabled dynamically. Often when a patch is introduced the a feature toggle (or flag) comes with it (as we will see below). **A feature flag in a function you suspect is related to a CVE might indicate you are looking in the right direction.** 

#### Modified

This diff has only **one modified function**. The best kind of result for a patch diff. :) 

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/ghidriff-cve-one-change.png){: .shadow }_`ghidriff` standard diff TOC_

The function `copy_from_lzss_window` is interesting from a security perspective. This CVE is an RCE, which can often mean some type of memory corruption. Taking a look at the vulnerable version of the binary we have both memory allocations, `memcpy`, and size checks. 

**Psuedo code from `copy_from_lzss_window`:**

```c
int copy_from_lzss_window(astruct *archive_read,void *buffer,int64_t startpos,int length)

{

// omitted code

// allocate some memory

  uVar4 = 0;
  _Size = (size_t)length;
  lVar1 = *archive_read->field2448_0x9a8;
  unp_buffer = *(LPCWSTR *)(lVar1 + 0xd0);
  if (unp_buffer == (LPCWSTR)0x0) {
    unp_buffer = (LPCWSTR)_o_malloc(*(undefined4 *)(lVar1 + 200));
    *(LPCWSTR *)(lVar1 + 0xd0) = unp_buffer;
    if (unp_buffer != (LPCWSTR)0x0) goto LAB_180036445;
    pcVar5 = "Unable to allocate memory for uncompressed data.";

// memcpy

   if (iVar2 < length) {
        memcpy(_Dst,_Src,(longlong)iVar2);
        _Src = *(void **)(lVar1 + 0x340);
        _Size = (size_t)(length - iVar2);
        _Dst = (void *)((ulonglong)(uint)(*(int *)(lVar1 + 0xc4) + iVar2) +
                       *(longlong *)(lVar1 + 0xd0));
      }
    }

// omitted code

  return iVar2;
}
```

The `copy_from_lzss_window` from the vulnerable version doesn't line up with the open-source code [tagged 3.6.2](https://github.com/libarchive/libarchive/blob/v3.6.2/libarchive/archive_read_support_format_rar.c#L3069), so we can't assume the code exactly aligns.
## Root cause

When patch diffing a CVE, we get to go and see for ourselves what changed in the binary. It is awesome. We can't always find the root cause just from the diff, but we can always learn more. For patch diffing a CVE, we can assume (or hope) the patch fixed a security issue. Sometimes this isn't the case. The primary difference in the function `copy_from_lzss_window` for the new version is the introduction of the Feature toggle and two size checks.

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/ghidriff-side-by-side-diffpreview-cve-2024-20696.png){: .shadow }_`ghidriff` side-by-side diff on [diffpreview.github.io](https://diffpreview.github.io/?538f86dc735fe9af5bbd568f3dbc3440)_

**Added Feature Flag and Checks**

```diff
--- copy_from_lzss_window
+++ copy_from_lzss_window
@@ -1,65 +1,66 @@

int copy_from_lzss_window(astruct *archive_read,void *buffer,int64_t startpos,int length)

// code omitted

 rar = (astruct_1 *)*archive_read->field2448_0x9a8;
+  uVar1 = Feature_3628230972__private_IsEnabled();
+  pWVar5 = (LPCWSTR)0x0;
+  if ((uVar1 == 0) || ((-1 < length && ((uint)length <= rar->unp_buffer_size)))) {
    pWVar2 = rar->field202_0xd0;
    if (pWVar2 == (LPCWSTR)0x0) {
      pWVar2 = (LPCWSTR)_o_malloc(rar->unp_buffer_size);
      rar->field202_0xd0 = pWVar2;
      if (pWVar2 == (LPCWSTR)0x0) {
        pcVar7 = "Unable to allocate memory for uncompressed data.";
        uVar4 = 0xc;
        goto LAB_18003732a;
      }
    }

// code omitted
```

Related function in [Github](https://github.com/libarchive/libarchive/blob/v3.5.2/libarchive/archive_read_support_format_rar.c)
### Speculating the Root Cause

If the `Feature_3628230972` is toggled off (`uVar1 = 0`), the checks are ignored and the original unpatched code runs. Otherwise the, `length` field is checked to ensure that it is smaller than `rar->unp_buffer_size` used for the allocation later used in `memcpy`.

**Added Size Check 1**
```c
(uint)length <= rar->unp_buffer_size
```

Size Check 2 ensures that the `length` passed into `lxss_copy_from_window` is non-negative.
The issue is that the value of the `length` is used for the `memcpy` later but treated as an `unsigned int`. 

```c
//   MOVSXD     RDI,R9D
_Size = (size_t)length;
```

When you cast a negative `int` and an `unsigned` one, that value becomes quite large. 

**Added Size Check 2**
```c
(-1 < length)
```

They added a new check to make sure that a particular `length` field was not negative (as that value will later be cast to an unsigned int making it very large and used in as a parameter for `memcpy`. 

#### Alternative: Root Cause with a Quick Google Search

One of the best thing to do with a function you don't know much about is google it and see what turns up. Well in this case we immediately come back with [a lead](https://github.com/libarchive/libarchive/issues/521).

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/libarchive-2015-cve.png){: .shadow }_Old Github  issue \#521 invalid read in `copy_from_lzss_window`_

An old CVE in the same function reported in 2015 caused an out-of-bounds read. This CVE was fixed in libarchive 3.2.1. This isn't that same issue we are seeing with this patch, but it does help us. The Github repo even provides a malformed `rar` [test case](https://github.com/libarchive/libarchive/commit/603454ec03040c29bd051fcc749e3c1433c11a8e?diff=split&w=0#diff-0e77a2aa3fee1941e81895488219ab238d7326d9d9699e816ef9aa704719ada7).  A test case is useful because it can lead us down the path of dynamic analysis.

### Dynamic Analysis

Something fun we can do in this case is try the broken `rar` file to get to the function. I wrote a quick demo program that will allow you to load the vulnerable `archiveint.dll` based on this test case. Well, I had a bit of help getting started. Only [two changes](https://github.com/clearbluejar/CVE-2024-20696/commit/3e14e0705a00f1f56c169a2acd3db558dac8b6c1) were needed to make the Copilot output compile. 

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/bing-copilot-fuzzing-harness-cve-2024-20696.png){: .shadow }_Copilot providing a quick test harness base_

I then [added](https://github.com/clearbluejar/CVE-2024-20696/commit/2969fc514212b9c71139b447ee2b60c906d0918e) the functionality from the broken [test case](https://github.com/libarchive/libarchive/blob/9ba8292aafacb7de8ff3629e823a862aa2ec569f/libarchive/test/test_read_format_rar_invalid1.c) to exercise the vulnerable code path.

If you want to play around with this go ahead and clone the repo at [https://github.com/clearbluejar/CVE-2024-20696](https://github.com/clearbluejar/CVE-2024-20696). Set a breakpoint on `archiveint.dll!copy_from_lzss_window`. Set `r9` to something really large. 
#### Attempting the broken RAR file

Using the test case we can hit the vulnerable function `archiveint.dll!copy_lzss_window`. 

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/windbg-cve-callstack.png){: .shadow }_WinDbg breaking on the vulnerable function_

Now using my `libarchive-harness-win.exe` we can hit the same path. 

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/vs-callstack-cve-2024-20696.png){: .shadow }_Hitting `copy_from_lzss_window` in Visual Studio_

The 2015 CVE test case doesn't trigger the issue patched in our CVE, but a quick tweak in the debugger can demonstrate what would happen if you could control the `length` parameter. When you set `length` to a negative int `$r9 = 0xF00000000` it will be sign extended here when cast to a `uint64` to `0xFFFFFFFF00000000` and become a very large integer. That integer is used in the `memcpy`

**Failing Size Check 2**

```c
  // length is cast to unsigned int
  _Size = (size_t)length;
  
  // What could go wrong?
  memcpy(_Dst,_Src,0xFFFFFFFF00000000);
```

The resulting call stack was actually an exception on the read, not quite RCE, but close? Besides, this CVE "exploitability" was rated "less likely". 

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/vs-callstack-cve-2024-20696-memcpy.png){: .shadow }_Access violation from `memcpy`_

In the patched version, setting `r9` to a large unsigned int is handled properly and the parsing of the `rar` test case just results in an error. I really want to build a `rar` that demonstrates the issue without modifying registers in the debugger, but the complexity of a creating a working `rar` file is prohibitive. Perhaps we can [fuzz](https://github.com/clearbluejar/CVE-2024-20696/blob/main/libarchive-harness-win.cpp#L30) it? 

WinAfl hasn't come up with it yet. Maybe check back in a few days? :) 

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/winafl-cve-2024-20696.png){: .shadow }_Kicking off WinAFL with `libarchive-win-harness.exe`_

## Wrapping Up

Well that concludes our patch diff of CVE-2024-20696 and our adventure with _libarchive_. It seems that Microsoft's internal build of libarchive (`archiveint.dll`) is now protected against a potential memory corruption from a suspect RAR file with an invalid length parameter. 

The diff was interesting because we could compare it against the open source version, had previous CVE examples, and only one function was changed. We determined that there are subtle differences in Microsoft's libarchive implementation. 

CVE-2024-20697 is another CVE in a different version of libarchive (3.6.2/Win11 rather than 3.5.2/Windows 10). Go ahead and try it. 


See what you come up with. I posted a result [here](https://diffpreview.github.io/?9574f311b3d3ff91d1ad0eb6c04138c0) if you want to compare.

One last thought. Interesting that Microsoft isn't using the latest version of libarchive. What about the [security issues]() found in later versions? 🤔

This concludes the first post in the Patch Tuesday Diffing Series. This time we tried `ghidriff` for diffing and we will try more as we go. If you like it, don't forget to send `ghidriff`  a ⭐️ on its [Github repo](https://github.com/clearbluejar/ghidriff).  

---

## Going Deeper

I hope this post inspires you to leverage the power of patch diffing to see a bit deeper into next month's Patch Tuesday.  If you want some free tips on patch diffing using native Ghidra check out my free online tutorial.
### CVE North Stars - Ghidra Patch Diffing Tutorial 

*A CVE provides a compass of sorts that orients and guides a researcher towards a deeper understanding of the patched vulnerability and its vulnerability class. The idea is to treat **CVEs as North Stars in vulnerability discovery and comprehension**.**

[https://cve-north-stars.github.io/](https://cve-north-stars.github.io/)
### Patch Diffing In The Dark - Blackhat Training USA 2024

![](/assets/img/2024-03-06-patch-tuesday-diffing-cve-2024-20696-windows-libarchive-rce/bh-usa-2024-patch-diffing-in-the-dark.png){: .shadow }_Patch Diffing In The Dark Blackhat USA 2024_

If you prefer to get more hands on, consider my upcoming Blackhat training "Patch Diffing in the Dark: Binary Diffing for Vulnerability Researchers and Reverse Engineers". In this in-person course, I will teach you how to leverage patch diffing to kick start your vulnerability research on both the Windows and Android platform. Together we will learn how to reverse engineer CVEs to hunt, find, and root cause modern vulnerabilities. 

The 2-day course is available on Saturday/Sunday or Monday/Tuesday. Early bird pricing is still available, but seats are limited -- secure your spot today!

[Saturday/Sunday Class Registration AUGUST 3-4](https://www.blackhat.com/us-24/training/schedule/#patch-diffing-in-the-dark-binary-diffing-for-vulnerability-researchers-and-reverse-engineers-37120)

[Monday/Tuesday Class Registration AUGUST 5-6](https://www.blackhat.com/us-24/training/schedule/#patch-diffing-in-the-dark-binary-diffing-for-vulnerability-researchers-and-reverse-engineers-371201705525888)

